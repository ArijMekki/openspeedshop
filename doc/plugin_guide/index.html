<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>HowToCreatePluginsForOpenSpeedShop</title>
</head>
<body>
<h1 style="text-align: center;"><br>
</h1>
<h1 style="text-align: center;"><img alt="Open|SpeedShop logo"
 src="OpenSpeedShop_Logo.jpg" style="width: 303px; height: 38px;"><br>
</h1>
<h1 style="text-align: center;"><a class="mozTocH1"
 name="mozTocId724479"></a>Plugin Creation Guide</h1>
<div style="text-align: center;"><big><span style="font-weight: bold;">Developer
Beta Release</span><br style="font-weight: bold;">
<span style="font-weight: bold;">November 13, 2005</span></big><br>
</div>
<br>
<h2><a class="mozTocH2" name="mozTocId240271"></a><span
 style="font-weight: bold;">Table of Contents</span><span
 style="text-decoration: underline;"></span></h2>
<ul id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6--><li><a href="#mozTocId724479">Open|SpeedShop
Plugin Creation Guide</a>
    <ul>
      <li><a href="#mozTocId240271">Table of Contents</a></li>
      <li><a href="#mozTocId535857">Open|SpeedShop
Overview and Information Resources</a>
        <ul>
          <li>
            <ul>
              <li><a href="#mozTocId507487">Features:</a></li>
              <li><a href="#mozTocId251693">Information Resources:</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#mozTocId11413">Open|SpeedShop Plugin
Overview </a></li>
      <li><a href="#mozTocId732797">Performance Data
Collector Plugin Information</a>
        <ul>
          <li><a href="#mozTocId661443">Identifying and Analyzing
The Performance Data Desired</a></li>
          <li><a href="#mozTocId904911">Implementing The
Collector Plugin</a>
            <ul>
              <li><a href="#mozTocId773274">Overview</a></li>
              <li><a href="#mozTocId207808">Data blobs</a></li>
              <li><a href="#mozTocId667687">Server - Collector
Runtime</a></li>
              <li><a href="#mozTocId637965">Client - Collector
Plugin&nbsp; </a>
                <ul>
                  <li><a href="#mozTocId388988">Start Collecting</a>
                    <ul>
                      <li><a href="#mozTocId199690">What
it does:</a></li>
                      <li><a href="#mozTocId219262">Definition:</a></li>
                      <li><a href="#mozTocId347609">Parameters:</a></li>
                      <li><a href="#mozTocId50896">What's needed in the
function body:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId992246">Stop Collecting</a>
                    <ul>
                      <li><a href="#mozTocId150755">What it does:</a></li>
                      <li><a href="#mozTocId352197">Definition:</a></li>
                      <li><a href="#mozTocId139139">Parameters:</a></li>
                      <li><a href="#mozTocId722160">What's needed in
the function body:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId278716">Get Metric Values</a>
                    <ul>
                      <li><a href="#mozTocId110227">What it does:</a></li>
                      <li><a href="#mozTocId171646">Definition:</a></li>
                      <li><a href="#mozTocId530275">Parameters:</a></li>
                      <li><a href="#mozTocId673416">What's needed in
the function body:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId271962">Set Parameter</a>
                    <ul>
                      <li><a href="#mozTocId753822">What it does:</a></li>
                      <li><a href="#mozTocId163320">Definition: </a></li>
                      <li><a href="#mozTocId699056"> Parameters:</a></li>
                      <li><a href="#mozTocId97265"> Return
values:</a></li>
                      <li><a href="#mozTocId259611">What's needed in
the function body:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId518369">Get Default
Parameters</a>
                    <ul>
                      <li><a href="#mozTocId709984">What it does:</a></li>
                      <li><a href="#mozTocId832976">Definition:</a></li>
                      <li><a href="#mozTocId646706">Return values:</a></li>
                      <li><a href="#mozTocId15384">What's needed in the
function body:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId769605">Get Parameters</a>
                    <ul>
                      <li><a href="#mozTocId340210">What it does:</a></li>
                      <li><a href="#mozTocId552888">Definition:</a></li>
                      <li><a href="#mozTocId731991">Parameters:</a></li>
                      <li><a href="#mozTocId705614">Return values:</a></li>
                      <li><a href="#mozTocId196328">What's needed in
the function body:</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId846999">Example Collector Plugin</a></li>
          <li><a href="#mozTocId377373">Collector
Plugin FAQ: </a>
            <ul>
              <li><a href="#mozTocId198444">What is
blob.x for? What is
the significance of the .x suffix? </a></li>
              <li><a href="#mozTocId189119">What is
specifically needed to be known by the framework? Do these class
structures need to follow a
particular convention?</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#mozTocId212847">Graphical User
Interface Plugin Information </a>
        <ul>
          <li><a href="#mozTocId930728">Creating A
Graphical User Interface Panel</a>
            <ul>
              <li><a href="#mozTocId570308">Initial Skeletal
Panel Creation - mknewpanel script</a></li>
              <li><a href="#mozTocId500145">Example Sections of Code</a>
                <ul>
                  <li><a href="#mozTocId66382">QtClass</a></li>
                  <li><a href="#mozTocId14581">TopLevel</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId1902">Interfacing With
Open|SpeedShop - Tips and Example Information</a>
            <ul>
              <li>
                <ul>
                  <li><a href="#mozTocId784520">Executing a command
through Command Line Interface (CLI)</a></li>
                  <li><a href="#mozTocId882832">Setting up a timer</a></li>
                  <li><a href="#mozTocId803177">Communicating with
other GUI panels</a></li>
                  <li><a href="#mozTocId525403">Managing process control</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId175785">Example Graphical
User Interface Plugin</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId1574">Command Line
Interface Plugin Information </a></li>
    </ul>
  </li>
</ul>
<h2><a class="mozTocH2" name="mozTocId535857"></a><a
 name="OpenSpeedShop_Overview_and_Information"></a>Open|SpeedShop
Overview and Information Resources</h2>
Open|SpeedShop is a project co-funded by the
Department of Energy (DOE), managed by the Tri-laboratories
of LLNL, LANL, and Sandia, and developed by SGI.&nbsp; Open|SpeedShop
utilizes dynamic instrumentation technology developed at the
Universities of Wisconsin and Maryland.
<br>
<br>
Open|SpeedShop is an open source multi platform Linux performance tool
which is initially targeted to support performance analysis of
applications running on both single node and large scale IA64, IA32,
EM64T, and AMD64 platforms. It is explicitly designed with usability in
mind and targets both application and computer scientists. <br>
&nbsp;<br>
Open|SpeedShop's base functionality includes metrics like exclusive and
inclusive user time, MPI call tracing, and CPU hardware performance
counter experiments.&nbsp; In addition, Open|SpeedShop is designed to
be modular and extensible.&nbsp; It supports several levels of plugins
which allow users to add their own performance experiments. <br>
<br>
The infrastructure and base components of Open|SpeedShop are being
released open source under GPL and LGPL.
<h4><a class="mozTocH4" name="mozTocId507487"></a>Features:</h4>
<ul>
  <li>Three modes of operation: batch, interactive command line
interface, and
graphical user interface.</li>
  <li>Multiple platform single system image (SSI), traditional cluster,
and SGI super cluster support.</li>
  <li>Support for large numbers of processes, threads, and ranks.</li>
  <li>Ability for users to create their own experiments via a well
defined plugin facility.<br>
  </li>
  <li>Ability to attach to running processes, threads, and ranks to
gather performance data.</li>
  <li>Ability to view performance data for all of application's
lifetime or smaller time slices.</li>
  <li>Ability to view performance data on demand (while the experiment
is running).</li>
  <li>Ability to save and restore performance experiment data and
symbol information to do post experiment performance analysis.</li>
  <li>Ability to compare performance results for processes, threads,
ranks, or to compare current experiment results with previous
experiment results.</li>
  <li>GUI Wizard facility and context sensitive help to aid in tools
usability.&nbsp; <br>
  </li>
  <li>CLI help facility which lists the CLI commands, syntax, and
typical usage. <br>
  </li>
</ul>
<h4><a class="mozTocH4" name="mozTocId251693"></a>Information Resources:</h4>
Additional information about Open|SpeedShop usage and design can be
found in a number of Open|SpeedShop documents.&nbsp; The currently
available documents are:<br>
<ul>
  <li><a href="../design_doc/index.html">Open|SpeedShop Design
Document&nbsp;</a> - Outlines the Open|SpeedShop design by major
component.<a href="../design_doc/index.html"><br>
    </a></li>
  <li><a href="../users_guide/index.html">Open|SpeedShop Users Guide</a>
- Describes build, installation, and usage of the Open|SpeedShop tools</li>
  <li><a href="../cli_doc/index.html">Open|SpeedShop Command Line
Interface</a> - Detailed description of the CLI commands and usage<br>
  </li>
  <li><a href="../test_plan/SGI_TestPlan.html">Open|SpeedShop Test Pla</a><a
 href="../test_plan/SGI_TestPlan.html">n</a> - Testing plan description<br>
  </li>
  <li><a href="../usability_plan/UsabilityPlanforOpenSpeedShop.html">Open|SpeedShop
Usability Study Plan and Detailed Results</a> - List of Usability
Studies and Results of Conducted Studies<br>
  </li>
</ul>
<br>
<h2><a class="mozTocH2" name="mozTocId11413"></a>Open|SpeedShop Plugin
Overview<br>
</h2>
The Open|SpeedShop performance tool is oriented toward gathering
performance data from user applications and relating that performance
data back to the application source file, function name and line
number(s).&nbsp;&nbsp;&nbsp; The data gathering, graphical user
interface displays, and the command line interface views are defined
via the Open|SpeedShop plugin mechanism.&nbsp;&nbsp; What this means is
that the code and data required to accomplish the above mentioned data
gathering, GUI control and display panels, and the CLI displays is
compiled into a dynamically loaded object called a plugin.&nbsp;&nbsp;
The Open|SpeedShop tools search a specified directory path or paths to
find the plugins and dynamically load them. &nbsp; Open|SpeedShop uses
the information inside the plugin to adjust the tools menus, internal
data structures, etc. to integrate the functionality contained in the
plugins into the tool.<br>
<br>
There are currently three separate types of Plugins that Open|SpeedShop
recognizes and dynamically integrates into the Open|SpeedShop tool
set.&nbsp; The three types of plugins are:<br>
<ul>
  <li>Performance data collector plugins<br>
  </li>
  <li>Graphical User Interface plugins</li>
  <li>Command Line Interface plugins</li>
</ul>
This document will outline each of the plugin types and give
instruction and examples of how to create and integrate plugins into
the Open|SpeedShop tools.<br>
<br>
<h3>Plugin Creation Preview Outline</h3>
Before getting into all the details, it may be helpful to outline the
steps involved in writing Open|SpeedShop plugins from a high
level.&nbsp; The following outline indicates the basic steps needed in
creating Open|SpeedShop plugins.&nbsp;&nbsp; If some steps aren't clear
at this point, don't despair, they will be explained later.&nbsp;&nbsp;
The purpose of this section is to give a broad overview and context to
the specific steps that are described in the rest of the document.<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId732797"></a>Performance Data
Collector Plugin Information</h2>
Writing a performance data collector consists of several
steps.&nbsp;&nbsp; The first step is to think about the performance
data that is to be collected.&nbsp; This first step can be
characterized as
identifying and analyzing the performance data desired.&nbsp;&nbsp; See
the
section below that is dedicated to the outlining the details associated
with this action.&nbsp; Once the
performance data criteria is resolved the next step in the collector
plugin creation is the actual implementation action.&nbsp;&nbsp; See
the sections below that are associated with implementation and also the
section detailing a performance data collector plugin example.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId661443"></a><a
 name="Idenitifying_and_Analysing_The"></a>Identifying and Analyzing
The Performance Data Desired</h3>
The first step is the thought process which
identifies the performance data desired to be collected.&nbsp; In other
words, "What performance information do we want to try and
collect?".&nbsp;&nbsp; Open|SpeedShop allows the user to collect the
performance data and then map the gathered data back to the program
source function name and/or source line numbers.&nbsp;&nbsp; So, one
question to be asked before starting to write a collector plugin for
Open|SpeedShop is can the performance data desired&nbsp; be associated
with
the program's source line and function addresses.&nbsp; Does the
performance data map back to the source?&nbsp;&nbsp; If so, then it is
a candidate
to be gathered by an Open|SpeedShop plugin.&nbsp;&nbsp;&nbsp; <br>
<br>
For
example, the PC Sampling experiment takes periodic samples of the
program address counter.&nbsp;&nbsp; A periodic timer is set and when
it triggers, the address of where the program is executing at that
point is
saved.&nbsp;&nbsp; The address can be mapped back to the source program
because we have saved the address in the program, as the performance
data
gathered.&nbsp;&nbsp; We can, by using debugging information, map the
saved
addresses back to the program's source.&nbsp;&nbsp; Actually, a set of
addresses and the count of the times each address is "hit" is saved.<br>
<br>
Another phase of the identify and analyze step is to identify and
define the metric and parameters.&nbsp; The metric is a function of the
time intervals and the instruction address space.&nbsp;&nbsp; It is
also the basic item of performance data that is to be gathered and
displayed by the collector plugin.&nbsp; The
parameter(s) can be thought of as the dial, selector, or knob that
controls how the data is collected.&nbsp;&nbsp; For example, the PC
Sampling experiment gathers the application's address at time intervals
across the applications running time.&nbsp; The time interval at which
each address sample is taken is the dial, selector, or knob controlling
how (actually when)&nbsp; the data is collected.&nbsp;&nbsp; The
metric, in this case, is
time spent in the application's functions and source line numbers based
on
translating the addresses, that were gathered, back to the source
function names and line numbers.<br>
<br>
Given that the "metric" is the performance data item desired to be
displayed and that the "parameter(s)" is the dial, selector, or knob to
control the collection of the "metric", lets examine these items in
more detail.&nbsp;&nbsp;&nbsp; <br>
<br>
Examples of metrics already being collected in Open|SpeedShop are:<br>
<ul>
  <li>Exclusive time - Time spent in this function only</li>
  <li>Inclusive time - Time spent in this function and all functions it
calls.</li>
  <li>Numbers of event occurances</li>
</ul>
Examples of parameters already supported by Open|SpeedShop are:<br>
<ul>
  <li>Sampling Rate in milliseconds</li>
  <li>Trigger Count Number of Events<br>
  </li>
</ul>
<br>
<span
 style="font-weight: bold; font-style: italic; text-decoration: underline;">Key
point: <br>
If the parameter is a type that is already supported by
Open|SpeedShop, additional GUI and/or CLI plugins may not have to be
written to support the new collector plugin.&nbsp;&nbsp; Since, the
existing types are recognized, a generic view can display the
performance data.<br>
</span><span
 style="font-weight: bold; font-style: italic; text-decoration: underline;"><br>
</span><br>
<h3><a class="mozTocH3" name="mozTocId904911"></a><a
 name="Implementating_The_Collector_Plugin"></a>Implementing The
Collector Plugin</h3>
<h4><a class="mozTocH4" name="mozTocId773274"></a>Overview</h4>
This section provides a brief implementation related overview of what
is going on inside Open|SpeedShop with respect to the interactions of
the collector plugin with the other components of the tool and with the
application being analyzed.&nbsp;&nbsp; A collector plugin will
facilitate
Open|SpeedShop to gather performance measurements that will be gathered
and stored temporarily in the victim application.&nbsp; This
performance data is sent from the victim application to the
Open|SpeedShop client when the performance data buffer fills up in the
victim application.&nbsp;&nbsp; When the Open|SpeedShop client receives
the performance data it is stored in the experiment database file.<br>
<br>
<img alt="Tool Overview" src="ToolOverView.png"
 style="width: 851px; height: 394px;"><br>
<br>
<h4><a class="mozTocH4" name="mozTocId207808"></a>Data blobs</h4>
The collector writer defines the format of the performance data being
gathered and stored in the victim application.&nbsp;&nbsp;
Open|SpeedShop uses the term, blob (binary large object), to refer to
the performance data objects being gathered and stored in the victim
application.&nbsp;&nbsp; There are design issues to consider when
defining the structure and size of the blob data:<br>
<ul>
  <li>Try not to use too much memory because the blob is contained in
the victim application.</li>
  <li>The blob should not be too small because having to send many
small blobs across the network could slow the network down.</li>
  <li>16k bytes has been found to be a reasonable size.&nbsp;&nbsp; PC
Sampling currently uses 8k bytes as the blob size.</li>
</ul>
Data blobs are specified in the XDR (External Data Representation)
language.&nbsp;&nbsp; XDR deals with endianess issues, data packing,
and other related issues.&nbsp;&nbsp; The XDR language looks like a C
structure definition and is specified in a file call
blob.x.&nbsp;&nbsp; This is what the collector plugin expects.&nbsp;
The blob.x file is fed into rpcgen which generates a ".c" file and a
".h" file.&nbsp; These files create a compilable C structure and
functions to convert the data to a C structure and back.<br>
<br>
<h4><a class="mozTocH4" name="mozTocId667687"></a>Server - Collector
Runtime</h4>
The collector runtime gathers data dependent on the type of performance
data the collector writer has decided to gather.&nbsp;&nbsp;&nbsp; The
collector runtime's purpose is to gather the data, package it, and send
it from the victim application to the Open|SpeedShop experiment
collector plugin client.&nbsp;&nbsp; Functionality that is generally
needed by collector runtime plugins includes the following:<br>
<ul>
  <li>Setting up a timer to trigger the gathering of performance data</li>
  <li>Using the PAPI overflow mechanism</li>
  <li>Obtaining a callstack entry</li>
  <li>Getting a program counter (PC) address</li>
  <li>Putting the collected data into a data blob</li>
  <li>Compressing the data to increase the bandwidth when sending to
the tool host (collector plugin client)<br>
  </li>
  <li>Sending the data to the tool host when the buffer (blob) fills up
and on program termination</li>
</ul>
There is also a set of commonly used shared functions that are bundled
into the Open|SpeedShop libopenss-runtime dynamic object.&nbsp;&nbsp;
These are functions that are used by more than one
collector.&nbsp;&nbsp; For example, some of the libunwind functionality
is contain in the libopenss-runtime dynamic object.<br>
<br>
<h4><a class="mozTocH4" name="mozTocId637965"></a>Client - Collector
Plugin&nbsp;<br>
</h4>
The client collector plugin activates the collector runtime by directly
and indirectly making calls to the collector runtime
functions.&nbsp;&nbsp;&nbsp; An example user action illustrates the
path between the client and runtime collector plugin
functionality.&nbsp;&nbsp; Suppose the user does an user interface
gesture that tells Open|SpeedShop to start
collecting.&nbsp;&nbsp;&nbsp; This triggers the user interface to call
the Open|SpeedShop framework which then accesses the start_collecting<br>
function in the client collector plugin.&nbsp;&nbsp; The client
collector plugin calls a Open|SpeedShop routine which ultimately
triggers the start collecting function in the runtime collector plugin.<br>
<br>
<img alt="Start Collection Illustration"
 src="ToolStartCollectingView.png" style="width: 696px; height: 342px;"><br>
<br>
There are six functions which form the basis for the collector and must
be defined in every collector plugin.&nbsp;&nbsp; The six functions
perform these tasks: <br>
<ul>
  <li>Start Collecting</li>
  <li>Stop Collecting</li>
  <li>Get Metric Values</li>
  <li>Set Parameter</li>
  <li>Get Default Parameters</li>
  <li>Get Parameters</li>
</ul>
<h5><a class="mozTocH5" name="mozTocId388988"></a><big>Start Collecting</big></h5>
<h6><a class="mozTocH6" name="mozTocId199690"></a><big><b><big><b>What
it does:</b></big></b></big></h6>
Start data collection function implements starting data collection for
a particular thread.<br>
<h6><a class="mozTocH6" name="mozTocId219262"></a><big><b><big><b>Definition:</b></big></b></big></h6>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<span style="font-style: italic;">void
UserTimeCollector::startCollecting (const Collector &amp;
collector,</span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Thread &amp; thread ) const</span><br>
<p></p>
<h6><a class="mozTocH6" name="mozTocId347609"></a><big><b>Parameters:</b></big></h6>
<dl compact="compact">
  <dt>The meaning or definitions for the arguments above are summarized
here:<span style="font-weight: bold;"></span></dt>
</dl>
<ol>
  <li>collector - The collector that will be starting data collection</li>
  <li>thread - The thread for which to start data collection.<br>
  </li>
</ol>
<h6><a class="mozTocH6" name="mozTocId50896"></a><big><b>What's needed
in the
function body:</b></big></h6>
<ol>
  <li>Assemble and encode collector arguments to the collectors start
collecting routine.</li>
  <li>Insert instrumentation to:</li>
</ol>
<ul style="margin-left: 40px;">
  <li>Execute collector's stop_sampling routine when we enter exit()
for the thread.</li>
  <li>Execute collector's start_sampling routine in the thread</li>
</ul>
<br>
<h5><a class="mozTocH5" name="mozTocId992246"></a><big>Stop Collecting</big></h5>
<h6><a class="mozTocH6" name="mozTocId150755"></a><big><b>What it does:</b></big></h6>
Stop data collection function implements stopping data collection for a
particular thread.<br>
<br>
<h6><a class="mozTocH6" name="mozTocId352197"></a><big><b>Definition:</b></big></h6>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<span style="font-style: italic;">void
UserTimeCollector::stopCollecting (const Collector &amp; collector,</span><br
 style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Thread &amp; thread ) const</span><br>
<p></p>
<h6><a class="mozTocH6" name="mozTocId139139"></a><big><b>Parameters:</b></big></h6>
<dl compact="compact">
  <dt>The meaning or definitions for the arguments above are summarized
here:<span style="font-weight: bold;"></span></dt>
</dl>
<ol>
  <li>collector - The collector that will be stopping data collection</li>
  <li>thread - The thread for which to stop data collection.<br>
  </li>
</ol>
<h6><a class="mozTocH6" name="mozTocId722160"></a><big><b>What's needed
in
the function body:</b></big></h6>
The primary tasks of this function that need to be done are:
<ol>
  <li>Insert instrumentation to execute the collector's stop_sampling
routine in the thread<br>
  </li>
  <li>Remove the instrumentation that was inserted by startCollecting:</li>
</ol>
<ul style="margin-left: 40px;">
  <li>Execute collector's stop_sampling routine when we enter exit()
for the thread.</li>
  <li>Execute collector's start_sampling routine in the thread</li>
</ul>
<small><b></b></small>
<h5><a class="mozTocH5" name="mozTocId278716"></a><big>Get Metric Values</big></h5>
<h6><a class="mozTocH6" name="mozTocId110227"></a><big><b>What it does:</b></big></h6>
This routine is used by the Open|SpeedShop framework to get the metrics
for each data blob the framework processes.&nbsp; The framework first
queries for address range extents and then calls the collector plugin
(getMetricValues) once for each data blob.&nbsp;&nbsp; Extents are
defined as a set of address ranges and a time interval.&nbsp;&nbsp; For
example, an address range could be the addresses in the function "xyz"
and the time interval could be the entire running time of the program.<br>
<h6><a class="mozTocH6" name="mozTocId171646"></a><big><b>Definition:</b></big></h6>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<span style="font-style: italic;">void
UserTimeCollector::getMetricValues(const std::string&amp; metric,</span><br
 style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Extent&amp; extent,</span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Blob&amp; blob,</span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const ExtentGroup&amp; subextents,</span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void* ptr) const<br>
</span>
<h6><a class="mozTocH6" name="mozTocId530275"></a><big><b>Parameters:</b></big></h6>
The meaning or definitions for the arguments above are summarized here:<br>
<ol>
  <li>metric - Unique identifier of the metric</li>
  <li>extent - Extent of the performance data blob</li>
  <li>blob - Blob containing the performance data</li>
  <li>subextents - The subextents for which to get the values</li>
  <li>ptr&nbsp; - Untyped pointer to the return values.</li>
</ol>
<h6><a class="mozTocH6" name="mozTocId673416"></a><big><b>What's needed
in
the function body:</b></big></h6>
The primary tasks of this function that need to be done are:<br>
<ol>
  <li>Process the collector's metric value(s) by iterating over the
blob containing the raw performance data.</li>
  <ul>
    <li>Check input parameters for validity</li>
    <li>Decode the data blob using XDR</li>
    <li>Using subextents to find out if there are metrics to return by
iterating over the samples in the data blob</li>
    <li>Do collector specific calculations for time, event counts, or
other</li>
  </ul>
  <li>Free the decoded performance data blob.</li>
</ol>
<h5><a class="mozTocH5" name="mozTocId271962"></a><big>Set Parameter</big></h5>
<h6><a class="mozTocH6" name="mozTocId753822"></a><big><b>What it does:</b></big></h6>
<p>The set a parameter function implements setting one of the collector
parameter values.<br>
</p>
<h6><a class="mozTocH6" name="mozTocId163320"></a><big><b>Definition:</b></big><br>
</h6>
<p>This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<span style="font-style: italic;">void
UserTimeCollector::setParameterValue(const std::string&amp;
parameter,</span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const void* ptr, </span><br style="font-style: italic;">
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Blob&amp; data) const</span><br>
</p>
<p></p>
<dl compact="compact">
</dl>
<h6><a class="mozTocH6" name="mozTocId699056"></a><small> </small><big><b>Parameters:</b></big></h6>
<ol>
  <li>parameter - Unique identifier of the input parameter to be set</li>
  <li>ptr - Untyped pointer to the parameter value</li>
</ol>
<dl compact="compact">
</dl>
<h6><a class="mozTocH6" name="mozTocId97265"></a><small> </small><big><b>Return
values:</b></big></h6>
<ol>
  <li>data - blob containing the parameter values for the collector</li>
</ol>
<h6><a class="mozTocH6" name="mozTocId259611"></a><big><b>What's needed
in
the function body:</b></big></h6>
The primary tasks of this function that need to be done are:<br>
<ol>
  <li>Decode the blob containing the parameter values</li>
  <li>Set the "collector specific" parameter based on the input</li>
  <li>Re-encode the blob containing the parameter values</li>
</ol>
<h5><a class="mozTocH5" name="mozTocId518369"></a><big>Get Default
Parameters</big></h5>
<h6><a class="mozTocH6" name="mozTocId709984"></a><big><b>What it does:</b></big></h6>
The get default parameters function implements getting the default
parameter set for the collector.<br>
<h6><a class="mozTocH6" name="mozTocId832976"></a><big><b>Definition:</b></big></h6>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<div style="text-align: left;"><span style="font-style: italic;">Blob
UserTimeCollector::getDefaultParameterValues() const</span><br
 style="font-style: italic;">
</div>
<h6><a class="mozTocH6" name="mozTocId646706"></a><big><b>Return values:</b></big></h6>
<ol>
  <li>data - Blob containing the default parameter values.</li>
</ol>
<h6><a class="mozTocH6" name="mozTocId15384"></a><big><b>What's needed
in the
function body:</b></big></h6>
The primary tasks of this function that need to be done are:<br>
<ol>
  <li>Setup an empty parameter structure</li>
  <li>Set the default parameters </li>
  <li>Return the encoded blob to the caller</li>
</ol>
<h5><a class="mozTocH5" name="mozTocId769605"></a><big>Get Parameters</big></h5>
<h6><a class="mozTocH6" name="mozTocId340210"></a><big><b>What it does:</b></big></h6>
The get a parameter function implements getting one of the collector
parameter values.<br>
<br>
<h6><a class="mozTocH6" name="mozTocId552888"></a><big><b>Definition:</b></big></h6>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
void UserTimeCollector::getParameterValue(const std::string&amp;
parameter,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Blob&amp; data, void* ptr) const<br>
<dl compact="compact">
  <dt><br>
  </dt>
</dl>
<h6><a class="mozTocH6" name="mozTocId731991"></a><big><b>Parameters:</b></big></h6>
<ol>
  <li>parameter - Unique identifier of the input parameter to be get.</li>
  <li>data - blob containing the parameter values for the collector</li>
</ol>
<dl compact="compact">
  <dt><br>
  </dt>
</dl>
<h6><a class="mozTocH6" name="mozTocId705614"></a><big><b>Return values:</b></big></h6>
<ol>
  <li>ptr - Untyped pointer to the parameter value</li>
</ol>
<h6><a class="mozTocH6" name="mozTocId196328"></a><big><b>What's needed
in the function body:</b></big></h6>
<small><b>
</b></small>
<ol>
  <li>Decode the data
blob containing the parameter values using XDR (External Data
Representation)</li>
  <li>Extract the parameter value from the decoded parameter value data
blob</li>
</ol>
<small><b><br>
</b></small>
<h3><a class="mozTocH3" name="mozTocId846999"></a><a
 name="Example_Collector_Plugin"></a>Example Collector Plugin</h3>
<br>
<h3><a class="mozTocH3" name="mozTocId377373"></a><b style="">Collector
Plugin FAQ:<br>
<span class="moz-txt-citetags"><span style="font-family: monospace;"></span></span></b></h3>
<h4><a class="mozTocH4" name="mozTocId198444"></a><b style="">What is
blob.x for? What is
the significance of the .x suffix?<br>
</b></h4>
<div class="Section13">
<div style="text-align: left;">
<blockquote><b style=""> </b>"blob.x" contains XDR descriptions of the
blobs (Binary Large OBjectS) used by the collector. The term "blob" is
a standard one in relational databases: <b style=""><br>
  <a class="moz-txt-link-freetext"
 href="http://www.hyperdictionary.com/dictionary/binary+large+object">http://www.hyperdictionary.com/dictionary/binary+large+object</a><br>
  <br>
  </b>And ".x" is the standard suffix used for XDR files. You can do
(this is
what I<br>
did) a search for "XDR file suffix" and you'll see that everyone uses
".x".<br>
  <br>
Collector parameters can be of any arbitrary type or structure. And the
raw data gathered by the collector can be of any arbitrary type or
structure. But the relational database doesn't know anything about
these types... So whenever<br>
parameters or raw performance data is stored in the database, it must
first be converted into a "chunk of bytes" (a blob). XDR is added to
the mix in order to easily handle things like endianess and structure
alignment issues. <b style=""><span class="moz-txt-citetags"><br>
  </span></b></blockquote>
</div>
<h4 style="text-align: left;"><a class="mozTocH4" name="mozTocId189119"></a><b
 style="">What is
specifically needed to be known by the framework? Do these<span
 class="moz-txt-citetags"> </span>class structures need to follow a
particular convention?</b></h4>
<div style="text-align: left;">
<blockquote> <b style=""> </b><!----> The naming of these files (e.g.
"blob.x" vs. "my_funny_file_name.x") makes no difference to the
framework. I believe Don was worried mainly about sticking to any
pre-existing naming convention (and I appreciate that). The only things<br>
that really matter to the framework are:<br>
  <br>
1) That a libtool-constructed module is placed into one of the plugin
search locations (see previous emails regarding how we decide where to
look for plugins). The name of the module itself is irrelevant
(although conventions are in place).<br>
  <br>
2) That the module defines an externally-visible function:<br>
  <br>
CollectorImpl* CollectorFactor();<br>
  <br>
which creates an CollectorImpl instance for the collector.<br>
  <br>
Each collector defines a single class (e.g. PCSampCollector or
UserTimeCollector) that inherits from CollectorImpl (which is in the
framework source). CollectorImpl declares a bunch of pure virtual
functions which all<br>
inheriting classes must implement. So you can think of
CollectorImpl.hxx as the "API" between the framework and the collectors.</blockquote>
</div>
</div>
<br>
<h2><a class="mozTocH2" name="mozTocId212847"></a>Graphical User
Interface Plugin Information<br>
</h2>
All of the Open|SpeedShop GUI functionality is implemented using the
GUI plugin mechanisms.&nbsp;&nbsp; To create an Open|SpeedShop GUI
plugin requires some knowledge about how to use the Qt GUI development
toolkit.&nbsp;&nbsp; A script is provided to help the GUI plugin
developer create a basic skeletal Open|SpeedShop Qt Panel.&nbsp;&nbsp;
The GUI plugin developer then must provide the widgets and Qt GUI
management routines to display what the plugin developer
desires.&nbsp;&nbsp;&nbsp; The basic skeletal Open|SpeedShop Qt Panel
code does provide some code options which can be uncommented and
modified in hopes of jump starting the process of developing additional
panels.<br>
<br>
Tips on interfacing with the rest of the Open|SpeedShop tool set are
also provided along with the example code.<br>
<h3><a class="mozTocH3" name="mozTocId930728"></a><a
 name="Creating_The_Graphical_User_Interface"></a>Creating A
Graphical User Interface Panel</h3>
<h4><a class="mozTocH4" name="mozTocId570308"></a>Initial Skeletal
Panel Creation - mknewpanel script</h4>
The "mknewpanel" script creates a basic Open|SpeedShop GUI Panel which
can then be modified to integrate with the core functionality of
Open|SpeedShop.&nbsp;&nbsp; This script can be found in the
subdirectory (from top of tree)
"plugins/panels/TemplatePanel".&nbsp;&nbsp; A "README" file in that
same directory gives "mknewpanel" usage information.&nbsp;&nbsp; The
same information can be obtained by running the "mknewpanel" script
without any arguments.&nbsp; The script modifies the TemplatePanel
sources in the TemplatePanel directory and creates a new subdirectory
under "plugins/panels" using the information given to it by the plugin
developer running the script.&nbsp;&nbsp; <br>
<br>
Here is the example output from the "mknewpanel" script creating a
Panel named "Test Panel" that will appear under the Performance menu in
Open|SpeedShop.&nbsp; Note that the initial execution of the Linux
command "ls" on the "plugins/panels" directory shows no directory named
"TestPanel".<br>
$ ls ..<br>
CmdPanel&nbsp;&nbsp; FPE_TracingPanel&nbsp;
Makefile&nbsp;&nbsp;&nbsp;&nbsp; ManageProcessesPanel&nbsp;
mysed&nbsp;&nbsp; StatsPanel<br>
CustomExperimentPanel&nbsp; HW_CounterPanel&nbsp;&nbsp;
Makefile.am&nbsp; MPIPanel&nbsp;&nbsp;&nbsp; pcSamplePanel&nbsp;
TemplatePanel<br>
DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile.in&nbsp;
mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
<br>
Now we run the "./mknewpanel" script which creates the TestPanel
subdirectory in "plugins/panels".<br>
<br>
$&nbsp; ./mknewpanel ../TestPanel TestPanel TestPanel "Test Panel"
"Cntrl B" 1 Performance<br>
PANEL_DIR=../TestPanel<br>
PANEL_NAME=TestPanel<br>
MENU_HEADING=TestPanel<br>
MENU_LABEL=Test Panel<br>
MENU_ACCEL=Cntrl B<br>
SHOW_IMMEDIATE=Performance<br>
PLUGIN_GROUPING=Performance<br>
Preparing to create your new TestPanel files.<br>
Succeeded: Finished creating files in ../TestPanel.<br>
You'll now need to edit the panels/Makefile.am to add this new
directory to the build list.<br>
You'll also need to modify the top level configure.ac file to add the
new directory to the list of directories to have makefiles created.<br>
<br>
When we do a "ls" Linux command for the "plugins/panels" directory we
now see a ""TestPanel subdirectory has been created.<br>
$ ls ..<br>
CmdPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HW_CounterPanel&nbsp;
Makefile.in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mysed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
TemplatePanel<br>
CustomExperimentPanel&nbsp;
IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ManageProcessesPanel&nbsp; pcSamplePanel&nbsp; <span
 style="font-weight: bold;">TestPanel</span><br>
DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MPIPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
FPE_TracingPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile.am&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
StatsPanel<br>
<br>
Doing a list of the files in the "TestPanel" subdirectory, we see that
the "mknewpanel" script has modified the "TemplatePanel" template code
and created similar files but renamed "TestPanel".<br>
<br>
Once the GUI plugin developer
modifies Open|SpeedShop's "configure.ac" (both in the top source
directory) and "Makefile.am" (in plugins/panels directory) files to
include the newly created panels and rebuilds Open|SpeedShop, the menu
item representing the panel
will be displayed under the menu that the GUI plugin developer provided
to the mknewpanel script.&nbsp;&nbsp; <br>
<ul>
  <li>In "configure.ac" add the
directory path to the newly created GUI plugin anywhere after the list
of "plugins/panels/&lt;panel name&gt;/Makefile"
entries.&nbsp;&nbsp; In this example, add
"plugins/panels/TestPanel/Makefile". <br>
  </li>
  <li>In "Makefile.am" add the name of the newly
created GUI plugin panel directory into the "SUBDIRS" list.</li>
</ul>
<h4><a class="mozTocH4" name="mozTocId500145"></a>Example Sections of
Code</h4>
The newly created GUI panel code has examples of GUI code that might be
interesting to an Open|SpeedShop GUI panel writer.<br>
<br>
<h5><a class="mozTocH5" name="mozTocId66382"></a>QtClass</h5>
This code snippet from the newly created "TestPanel.cxx" can be enabled
and modified to use the GUI panel writer's QtDesigner created
class.&nbsp;&nbsp; When modified and enabled the GUI panel writer will
see what they created in QtDesigner in the "TestPanel"
display.&nbsp;&nbsp;&nbsp; Use "#define QTCLASS" or remove the "#ifdef
QTCLASS" and "#endif // QTCLASS" to enable this section of code.<br>
<br>
<small>#include &lt;qlistview.h&gt;&nbsp; // For QListView<br>
#include &lt;qvaluelist.h&gt;&nbsp; // For QTextEdit in example below...<br>
#include &lt;qsplitter.h&gt;&nbsp; // For QSplitter in example below...<br>
#include &lt;chartform.hxx&gt;&nbsp; // For chart in example below...<br>
TestPanel::TestPanel(PanelContainer *pc, const char *n, void *argument)
: Panel(pc, n)<br>
{<br>
&nbsp; setCaption("TestPanel");<br>
&nbsp; frameLayout = new QVBoxLayout( getBaseWidgetFrame(), 1, 2,
getName() );<br>
<br>
#ifdef QTCLASS<br>
// Here's an example of&nbsp; adding a class you created with
QtDesigner...<br>
// Defining QtClass (above) will enable this block.<br>
// This block will include a class that you designed with QtDesigner.<br>
&nbsp; YourClass *ppc = new YourClass(getBaseWidgetFrame(), getName() );<br>
&nbsp; frameLayout-&gt;addWidget( ppc );<br>
&nbsp; ppc-&gt;show();<br>
#endif // QTCLASS</small><br>
<br>
<h5><a class="mozTocH5" name="mozTocId14581"></a>TopLevel</h5>
This code snippet from the newly created "TestPanel.cxx" can be enabled
and modified to create a GUI panel similar to the PCSampling and
UserTime experiment panels.&nbsp;&nbsp;
When modified and enabled the GUI panel writer will Run, Pause, Update,
and Terminate process control buttons created in the "TestPanel"
display.&nbsp;&nbsp;&nbsp; Use "#define TOPLEVEL" or remove the "#ifdef
TOPLEVEL" and "#endif // TOPLEVEL" to
enable this section of code.&nbsp; As the comments in the code say, the
GUI panel writer can look at existing panels such as the PC Sampling
Experiment panel in the PCSamplePanel directory.<br>
<br>
<small><br>
#ifdef TOPLEVEL<br>
// Here's an example of a putting a name toplevel panel container in the<br>
// panel.<br>
// Defining TOPLEVEL (above) will enable this block.<br>
// This block will create an outline much like the pcSamplePanel and<br>
// UserTimePanel experiments.<br>
// A process control panel (run, pause, update, terminate) will be
created<br>
// and a panel container to place child panels will be created.<br>
// See pcSamplePanel for a working example.<br>
&nbsp; ProcessControlObject *pco = new
ProcessControlObject(frameLayout, getBaseWidgetFrame(), (Panel *)this );<br>
<br>
&nbsp; QHBoxLayout *statusLayout = new QHBoxLayout( 0, 10, 0,
"statusLayout" );<br>
<br>
&nbsp; QLabel *statusLabel = new QLabel( getBaseWidgetFrame(),
"statusLabel");<br>
&nbsp; statusLayout-&gt;addWidget( statusLabel );<br>
<br>
&nbsp; QLineEdit *statusLabelText = new QLineEdit(
getBaseWidgetFrame(), "statusLabelText");<br>
&nbsp; statusLabelText-&gt;setReadOnly(TRUE);<br>
&nbsp; statusLayout-&gt;addWidget( statusLabelText );<br>
<br>
&nbsp; frameLayout-&gt;addLayout( statusLayout );<br>
<br>
&nbsp; QWidget *namedPanelContainerWidget = new QWidget(
getBaseWidgetFrame(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"namedPanelContainerWidget" );<br>
&nbsp; PanelContainer *topPPL = createPanelContainer(
namedPanelContainerWidget, "", NULL, pc-&gt;getMasterPCList() );<br>
&nbsp; frameLayout-&gt;addWidget( namedPanelContainerWidget );<br>
<br>
//&nbsp; namedPanelContainerWidget-&gt;show();<br>
&nbsp; topPPL-&gt;show();<br>
&nbsp; topPPL-&gt;topLevel = TRUE;<br>
#endif // TOPLEVEL</small><br>
<br>
<h3><a class="mozTocH3" name="mozTocId1902"></a>Interfacing With
Open|SpeedShop - Tips and Example Information</h3>
<h5><a class="mozTocH5" name="mozTocId784520"></a>Executing a command
through Command Line Interface (CLI)</h5>
<span style="font-weight: bold;"></span>The GUI panels use the same
commands that an interactive user would.&nbsp; The Open|SpeedShop tool
was designed in this manner to prevent the interactive command line
interface tool, the batch tool, and the GUI from diverging and doing
basic functions differently.&nbsp;&nbsp; This makes coding a GUI panel
slightly more intuitive.&nbsp; If the GUI panel writer knows what
function they would like the GUI panel to execute, then they can look
at the interactive command line interface documentation and see if that
function is covered by an existing command.&nbsp;&nbsp; The Command
Line Interface document can be accessed by clicking <a
 href="../cli_doc/index.html">here</a>.<br>
<br>
This case block taken from the pcSamplePanel.cxx file illustrates how
CLI commands are passed to the CLI from the GUI.<br>
<br>
<small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case&nbsp; PAUSE_T:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nprintf( DEBUG_MESSAGES )
("Pause\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command = QString("expPause
-x %1\n").arg(expID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int wid =
getPanelContainer()-&gt;getMainWindow()-&gt;widStr.toInt();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cli-&gt;runSynchronousCLI(command.ascii());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statusLabelText-&gt;setText(
tr("Process Paused...") );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_val = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</small><br>
<br>
<br>
<h5><a class="mozTocH5" name="mozTocId882832"></a>Setting up a timer</h5>
<h5><a class="mozTocH5" name="mozTocId803177"></a>Communicating with
other GUI panels</h5>
pcSamplePanel::listener(void *msg)<br>
<br>
<h5><a class="mozTocH5" name="mozTocId525403"></a>Managing process
control</h5>
<br>
<br>
<h3><a class="mozTocH3" name="mozTocId175785"></a><a
 name="Example_Graphical_User_Interface_Plugin"></a>Example Graphical
User Interface Plugin</h3>
<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId1574"></a>Command Line
Interface Plugin Information<br>
</h2>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
