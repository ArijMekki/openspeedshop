<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>HowToCreatePluginsForOpenSpeedShop</title>
</head>
<body>
<h1 style="text-align: center;"><a class="mozTocH1"
 name="mozTocId724479"></a>Open|SpeedShop Plugin Creation Guide</h1>
<div style="text-align: center;"><big><span style="font-weight: bold;">Developer
Beta Release</span><br style="font-weight: bold;">
<span style="font-weight: bold;">November 13, 2005</span></big><br>
</div>
<br>
<h2><a class="mozTocH2" name="mozTocId240271"></a><span
 style="font-weight: bold;">Table of Contents</span><span
 style="text-decoration: underline;"></span></h2>
<ul id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6--><li><a href="#mozTocId724479">Open|SpeedShop
Plugin Creation Guide</a>
    <ul>
      <li><a href="#mozTocId240271">Table of Contents</a></li>
      <li><a href="#mozTocId535857">Open|SpeedShop
Overview and Information Resources</a>
        <ul>
          <li><a href="#mozTocId507487">Features:</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId11413">Open|SpeedShop Plugin
Overview </a></li>
      <li><a href="#mozTocId732797">Performance Data
Collector Plugin Information</a>
        <ul>
          <li><a href="#mozTocId661443">Identifying and Analyzing
The Performance Data Desired</a></li>
          <li><a href="#mozTocId904911">Implementing The
Collector Plugin</a>
            <ul>
              <li><a href="#mozTocId773274">Overview</a></li>
              <li><a href="#mozTocId207808">Data blobs</a></li>
              <li><a href="#mozTocId667687">Server - Collector
Runtime</a></li>
              <li><a href="#mozTocId637965">Client - Collector
Plugin&nbsp; </a>
                <ul>
                  <li><a href="#mozTocId388988">Start Collecting</a></li>
                  <li><a href="#mozTocId992246">Stop Collecting</a></li>
                  <li><a href="#mozTocId278716">Get Metric Values</a></li>
                  <li><a href="#mozTocId271962">Set Parameter</a></li>
                  <li><a href="#mozTocId518369">Get Default Parameters</a></li>
                  <li><a href="#mozTocId769605">Get Parameters</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId846999">Example Collector Plugin</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId212847">Graphical User
Interface Plugin Information </a>
        <ul>
          <li><a href="#mozTocId930728">Creating A
Graphical User Interface Panel</a></li>
          <li><a href="#mozTocId963628">Interfacing With
Open|SpeedShop - Tips and Example Information</a></li>
          <li><a href="#mozTocId175785">Example Graphical
User Interface Plugin</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId1574">Command Line
Interface Plugin Information </a></li>
    </ul>
  </li>
</ul>
<h2><a class="mozTocH2" name="mozTocId535857"></a><a
 name="OpenSpeedShop_Overview_and_Information"></a>Open|SpeedShop
Overview and Information Resources</h2>
Open|SpeedShop is a project co-funded by the
Department of Energy (DOE), managed by the Tri-laboratories
of LLNL, LANL, and Sandia, and developed by SGI.&nbsp; Open|SpeedShop
utilizes dynamic instrumentation technology developed at the
Universities of Wisconsin and Maryland.
<br>
<br>
Open|SpeedShop is an open source multi platform Linux performance tool
which is initially targeted to support performance analysis of
applications running on both single node and large scale IA64, IA32,
EM64T, and AMD64 platforms. It is explicitly designed with usability in
mind and targets both application and computer scientists. <br>
&nbsp;<br>
Open|SpeedShop's base functionality includes metrics like exclusive and
inclusive user time, MPI call tracing, and CPU hardware performance
counter experiments.&nbsp; In addition, Open|SpeedShop is designed to
be modular and easily extendable. It supports several levels of plugins
which allow users to add their own performance experiments. <br>
<br>
The infrastructure and base components of Open|SpeedShop are being
released open source under GPL and LGPL.
<h4><a class="mozTocH4" name="mozTocId507487"></a>Features:</h4>
<ul>
  <li>Three modes of operation: batch, interactive command line
interface, and
graphical user interface.</li>
  <li>Multiple platform single system image (SSI), traditional cluster,
and SGI super cluster support.</li>
  <li>Support for large numbers of processes, threads, and ranks.</li>
  <li>Ability for users to create their own experiments via a well
defined plugin facility.<br>
  </li>
  <li>Ability to attach to running processes, threads, and ranks to
gather performance data.</li>
  <li>Ability to view performance data for all of application's
lifetime or smaller time slices.</li>
  <li>Ability to view performance data on demand (while the experiment
is running).</li>
  <li>Ability to save and restore performance experiment data and
symbol information to do post experiment performance analysis.</li>
  <li>Ability to compare performance results for processes, threads,
ranks, or to compare current experiment results with previous
experiment results.</li>
  <li>GUI Wizard facility and context sensitive help to aid in tools
usability.&nbsp; <br>
  </li>
  <li>CLI help facility which lists the CLI commands, syntax, and
typical usage. <br>
  </li>
</ul>
Additional information about Open|SpeedShop usage and design can be
found in a number of Open|SpeedShop documents.&nbsp; The currently
available documents are:<br>
<ul>
  <li><a href="../design_doc/index.html">Open|SpeedShop Design
Document&nbsp;</a> - Outlines the Open|SpeedShop design by major
component.<a href="../design_doc/index.html"><br>
    </a></li>
  <li><a href="../users_guide/index.html">Open|SpeedShop Users Guide</a>
- Describes build, installation, and usage of the Open|SpeedShop tools</li>
  <li><a href="../cli_doc/index.html">Open|SpeedShop Command Line
Interface</a> - Detailed description of the CLI commands and usage<br>
  </li>
  <li><a href="../test_plan/SGI_TestPlan.html">Open|SpeedShop Test Pla</a><a
 href="../test_plan/SGI_TestPlan.html">n</a> - Testing plan description<br>
  </li>
  <li><a href="../usability_plan/UsabilityPlanforOpenSpeedShop.html">Open|SpeedShop
Usability Study Plan and Detailed Results</a> - List of Usability
Studies and Results of Conducted Studies<br>
  </li>
</ul>
<br>
<h2><a class="mozTocH2" name="mozTocId11413"></a>Open|SpeedShop Plugin
Overview<br>
</h2>
The Open|SpeedShop performance tool is oriented toward gathering
performance data from user applications and relating that performance
data back to the application source file, function name and line
number(s).&nbsp;&nbsp;&nbsp; The data gathering, graphical user
interface displays, and the command line interface views are defined
via the Open|SpeedShop plugin mechanism.&nbsp;&nbsp; What this means is
that the code and data required to accomplish the above mentioned data
gathering, GUI control and display panels, and the CLI displays is
compiled into a dynamically loaded object called a plugin.&nbsp;&nbsp;
The Open|SpeedShop tools search a specified directory path or paths to
find the plugins and dynamically load them. &nbsp; Open|SpeedShop uses
the information inside the plugin to adjust the tools menus, internal
data structures, etc. to integrate the functionality contained in the
plugins into the tool.<br>
<br>
There are currently three separate types of Plugins that Open|SpeedShop
recognizes and dynamically integrates into the Open|SpeedShop tool
set.&nbsp; The three types of plugins are:<br>
<ul>
  <li>Performance data collector plugins<br>
  </li>
  <li>Graphical User Interface plugins</li>
  <li>Command Line Interface plugins</li>
</ul>
This document will outline each of the plugin types and give
instruction and examples of how to create and integrate plugins into
the Open|SpeedShop tools.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId732797"></a>Performance Data
Collector Plugin Information</h2>
Writing a performance data collector consists of several
steps.&nbsp;&nbsp; The first action is to think about the performance
data that is to be collected.&nbsp; This action can be characterized as
identifying and analyzing the performance data desired.&nbsp; See the
section below for details associated with this action.&nbsp; Once the
performance data criteria is resolved the next action in the collector
plugin creation is the actual implementation action.&nbsp;&nbsp; See
the sections below that are associated with implementation and examples.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId661443"></a><a
 name="Idenitifying_and_Analysing_The"></a>Identifying and Analyzing
The Performance Data Desired</h3>
The first step is the thought process which
identifies the performance data desired to be collected.&nbsp; In other
words, "What performance information do we want to try and
collect?".&nbsp;&nbsp; Open|SpeedShop allows the user to collect the
performance data and then map the gathered data back to the program
source function name and/or source line numbers.&nbsp;&nbsp; So, one
question to be asked before starting to write a collector plugin for
Open|SpeedShop is can the performance data desired be associated with
the program's source line and function addresses.&nbsp;&nbsp; Does the
performance data map back to the source?&nbsp;&nbsp; If so, then it is
a candidate
to be gathered by an Open|SpeedShop plugin.&nbsp;&nbsp;&nbsp; <br>
<br>
For
example, the PC Sampling experiment takes periodic samples of the
program address counter.&nbsp;&nbsp; A periodic timer is set and when
it goes off, the address of where the program is at, is
saved.&nbsp;&nbsp; This can be mapped back to the source program
because we have the address in the program, as the performance data
gathered.&nbsp;&nbsp; We can, by using debugging information, map the
address back to the program's source.&nbsp;&nbsp; <br>
<br>
Another phase of the identify and analyze step is to identify and
define the metric and parameters.&nbsp; The metric is a function of the
time intervals and the instruction address space.&nbsp;&nbsp; The
metric is the basic item of performance data that is to be gathered and
displayed by the collector plugin.&nbsp; The
parameter(s) can be thought of as the dial, selector, or knob that
controls how the data is collected.&nbsp;&nbsp; For example, the PC
Sampling experiment gathers the application's address at time intervals
across the applications running time.&nbsp; The time interval at which
each address sample is taken is the dial, selector, or knob control
how, actually when, the data is collected.&nbsp;&nbsp; The metric is
time spent in the application's functions and line numbers based on
translating the addresses that were gathered back to the source
function names and line numbers.<br>
<br>
Given that the "metric" is the performance data item desired to be
displayed and that the "parameter(s)" is the dial, selector, or knob to
control the collection of the "metric", lets examine these items in
more detail.&nbsp;&nbsp;&nbsp; <br>
<br>
<br>
<span
 style="font-weight: bold; font-style: italic; text-decoration: underline;">Key
point: If the parameter is a type that is already supported by
Open|SpeedShop, additional GUI and/or CLI plugins may not have to be
written to support the new collector plugin.&nbsp;&nbsp; Since, the
existing types are recognized, a generic view can display the
performance data.<br>
<br>
</span>TBD - need more here................<span
 style="font-weight: bold; font-style: italic; text-decoration: underline;"><br>
</span><br>
<h3><a class="mozTocH3" name="mozTocId904911"></a><a
 name="Implementating_The_Collector_Plugin"></a>Implementing The
Collector Plugin</h3>
<h4><a class="mozTocH4" name="mozTocId773274"></a>Overview</h4>
This section provides a brief implementation related overview of what
is going on inside Open|SpeedShop with respect to the interactions of
the collector plugin with the other components of the tool and with the
application being analyzed.&nbsp;&nbsp; The collector plugin will cause
Open|SpeedShop to gather performance measurements that will be gathered
and stored temporarily in the victim application.&nbsp; This
performance data is sent from the victim application to the
Open|SpeedShop client when the performance data buffer fills up in the
victim application.&nbsp;&nbsp; When the Open|SpeedShop client receives
the performance data it is stored in the experiment database file.<br>
<br>
<img alt="Tool Overview" src="ToolOverView.png"
 style="width: 851px; height: 394px;"><br>
<br>
<h4><a class="mozTocH4" name="mozTocId207808"></a>Data blobs</h4>
The collector writer defines the format of the performance data being
gathered and stored in the victim application.&nbsp;&nbsp;
Open|SpeedShop uses the term, blob (binary large object), to refer to
the performance data objects being gathered and stored in the victim
application.&nbsp;&nbsp; There are design issues to consider when
defining the structure and size of the blob data:<br>
<ul>
  <li>Try not to use too much memory because the blob is contained in
the victim application.</li>
  <li>The blob should not be too small because having to send many
small blobs across the network could slow the network down.</li>
  <li>16k bytes has been found to be a reasonable size.&nbsp;&nbsp; PC
Sampling currently uses 8k bytes as the blob size.</li>
</ul>
Data blobs are specified in the XDR (External Data Representation)
language.&nbsp;&nbsp; XDR deals with endianess issues, data packing,
and other related issues.&nbsp;&nbsp; The XDR language looks like a C
structure definition and is specified in a file call
blob.x.&nbsp;&nbsp; This is what the collector plugin expects.&nbsp;
The blob.x file is fed into rpcgen which generates a ".c" file and a
".h" file.&nbsp; These files create a compilable C structure and
functions to convert the data to a C structure and back.<br>
<br>
<h4><a class="mozTocH4" name="mozTocId667687"></a>Server - Collector
Runtime</h4>
The collector runtime gathers data dependent on the type of performance
data the collector writer has decided to gather.&nbsp;&nbsp;&nbsp; The
collector runtime's purpose is to gather the data, package it, and send
it from the victim application to the Open|SpeedShop experiment
collector plugin client.&nbsp;&nbsp; Functionality that is generally
needed by collector runtime plugins includes the following:<br>
<ul>
  <li>Setting up a timer to trigger the gathering of performance data</li>
  <li>Using the PAPI overflow mechanism</li>
  <li>Obtaining a callstack entry</li>
  <li>Getting a program counter (PC) address</li>
  <li>Putting the collected data into a data blob</li>
  <li>Compressing the data to increase the bandwidth when sending to
the tool host (collector plugin client)<br>
  </li>
  <li>Sending the data to the tool host when the buffer (blob) fills up
and on program termination</li>
</ul>
There is also a set of commonly used shared functions that are bundled
into the Open|SpeedShop libopenss-runtime dynamic object.&nbsp;&nbsp;
These are functions that are used by more than one
collector.&nbsp;&nbsp; For example, some of the libunwind functionality
is contain in the libopenss-runtime dynamic object.<br>
<br>
<h4><a class="mozTocH4" name="mozTocId637965"></a>Client - Collector
Plugin&nbsp;<br>
</h4>
The client collector plugin directs the collector runtime by directly
and indirectly making calls to the collector runtime
functions.&nbsp;&nbsp;&nbsp; An example user action illustrates the
path between the client and runtime collector plugin
functionality.&nbsp;&nbsp; Suppose the user does an user interface
gesture that tells Open|SpeedShop to start
collecting.&nbsp;&nbsp;&nbsp; This triggers the user interface to call
the Open|SpeedShop framework which then accesses the start_collecting<br>
function in the client collector plugin.&nbsp;&nbsp; The client
collector plugin calls a Open|SpeedShop routine which ultimately
triggers the start collecting function in the runtime collector plugin.<br>
<br>
<img alt="Start Collection Illustration"
 src="ToolStartCollectingView.png" style="width: 696px; height: 342px;"><br>
<br>
There are six functions which form the basis for the collector and must
be defined in every collector plugin.&nbsp;&nbsp; The six functions
perform these tasks: <br>
<ul>
  <li>Start Collecting</li>
  <li>Stop Collecting</li>
  <li>Get Metric Values</li>
  <li>Set Parameter</li>
  <li>Get Default Parameters</li>
  <li>Get Parameters</li>
</ul>
<h5><a class="mozTocH5" name="mozTocId388988"></a>Start Collecting</h5>
Start data collection function implements starting data collection for
a particular thread.<br>
<br>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<br>
void UserTimeCollector::startCollecting (const Collector &amp;
collector,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Thread &amp; thread ) const<br>
<p></p>
<dl compact="compact">
  <dt><small><b>Parameters:</b></small></dt>
  <dt>The meaning or definitions for the arguments above are summarized
here:<span style="font-weight: bold;"></span></dt>
</dl>
<ol>
  <li>collector - The collector that will be starting data collection</li>
  <li>thread - The thread for which to start data collection.<br>
  </li>
</ol>
<br>
<h5><a class="mozTocH5" name="mozTocId992246"></a>Stop Collecting</h5>
Stop data collection function implements stopping data collection for a
particular thread.<br>
<br>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<br>
void UserTimeCollector::stopCollecting (const Collector &amp; collector,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Thread &amp; thread ) const<br>
<p>
</p>
<dl compact="compact">
  <dt><small><b>Parameters:</b></small></dt>
  <dt>The meaning or definitions for the arguments above are summarized
here:<span style="font-weight: bold;"></span></dt>
</dl>
<ol>
  <li>collector - The collector that will be stopping data collection</li>
  <li>thread - The thread for which to stop data collection.<br>
  </li>
</ol>
<br>
<h5><a class="mozTocH5" name="mozTocId278716"></a>Get Metric Values</h5>
This routine is used by the Open|SpeedShop framework to get the metrics
for each data blob the framework processes.&nbsp; The framework first
queries for address range extents and then calls the collector plugin
(getMetricValues) once for each data blob.&nbsp;&nbsp; Extents are
defined as a set of address ranges and a time interval.&nbsp;&nbsp; For
example, an address range could be the addresses in the function "xyz"
and the time interval could be the entire running time of the program.<br>
<br>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<br>
void UserTimeCollector::getMetricValues(const std::string&amp; metric,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Extent&amp; extent,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Blob&amp; blob,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const ExtentGroup&amp; subextents,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void* ptr) const<br>
<small><b>Parameters:</b></small><br>
The meaning or definitions for the arguments above are summarized here:<br>
<ol>
  <li>metric - Unique identifier of the metric</li>
  <li>extent - Extent of the performance data blob</li>
  <li>blob - Blob containing the performance data</li>
  <li>subextents - The subextents for which to get the values</li>
  <li>ptr&nbsp; - Untyped pointer to the return values.</li>
</ol>
<h5><a class="mozTocH5" name="mozTocId271962"></a>Set Parameter</h5>
<br>
<p>The set a parameter function implements setting one of the collector
parameter values.<br>
</p>
<p>This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:</p>
<p>void UserTimeCollector::setParameterValue(const std::string&amp;
parameter,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const void* ptr, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Blob&amp; data) const<br>
</p>
<p></p>
<dl compact="compact">
  <small> </small><dt><small><b>Parameters:</b></small></dt>
  <small></small>
</dl>
<ol>
  <li>parameter - Unique identifier of the input parameter to be set</li>
  <li>ptr - Untyped pointer to the parameter value</li>
</ol>
<dl compact="compact">
  <small> </small><dt><small><b>Return values:</b></small></dt>
  <small></small>
</dl>
<ol>
  <li>data - blob containing the parameter values for the collector<br>
  </li>
</ol>
<h5><a class="mozTocH5" name="mozTocId518369"></a>Get Default Parameters</h5>
The get default parameters function implements getting the default
parameter set for the collector.<br>
<br>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
<br>
Blob UserTimeCollector::getDefaultParameterValues() const<br>
<dl compact="compact">
  <dt><small><b>Return values:</b></small></dt>
</dl>
<ol>
  <li>data - Blob containing the default parameter values.</li>
</ol>
<h5><a class="mozTocH5" name="mozTocId769605"></a>Get Parameters</h5>
<small><b>What it does:</b></small><br>
The get a parameter function implements getting one of the collector
parameter values.<br>
<br>
<small><b>Definition:</b></small><br>
This is an example definition from the Open|SpeedShop Usertime
Collector Plugin:<br>
void UserTimeCollector::getParameterValue(const std::string&amp;
parameter,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const Blob&amp; data, void* ptr) const<br>
<dl compact="compact">
  <dt><small><b>Parameters:</b></small></dt>
</dl>
<ol>
  <li>parameter - Unique identifier of the input parameter to be get.</li>
  <li>data - blob containing the parameter values for the collector</li>
</ol>
<dl compact="compact">
  <dt><small><b>Return values:</b></small></dt>
</dl>
<ol>
  <li>ptr - Untyped pointer to the parameter value</li>
</ol>
<small><b>What is in the function body:<br>
<br>
</b></small>The body of the getParameterValue function decodes the data
blob containing the parameter values using XDR (External Data
Representation).<br>
<small><b><br>
<br>
</b></small>
<h3><a class="mozTocH3" name="mozTocId846999"></a><a
 name="Example_Collector_Plugin"></a>Example Collector Plugin</h3>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId212847"></a>Graphical User
Interface Plugin Information<br>
</h2>
All of the Open|SpeedShop GUI functionality is implemented using the
GUI plugin mechanisms.&nbsp;&nbsp; To create an Open|SpeedShop GUI
plugin requires some knowledge about how to use the Qt GUI development
toolkit.&nbsp;&nbsp; A script is provided to help the GUI plugin
developer create a basic skeletal Open|SpeedShop Qt Panel.&nbsp;&nbsp;
The GUI plugin developer then must provide the widgets and Qt GUI
management routines to display what the plugin developer
desires.&nbsp;&nbsp;&nbsp; The basic skeletal Open|SpeedShop Qt Panel
code does provide some code options which can be uncommented and
modified in hopes of jump starting the process of developing additional
panels.<br>
<br>
Tips on interfacing with the rest of the Open|SpeedShop tool set are
also provided along with the example code.<br>
<h3><a class="mozTocH3" name="mozTocId930728"></a><a
 name="Creating_The_Graphical_User_Interface"></a>Creating A
Graphical User Interface Panel</h3>
<h4>Initial Skeletal Panel Creation - mknewpanel script</h4>
The "mknewpanel" script creates a basic Open|SpeedShop GUI Panel which
can then be modified to integrate with the core functionality of
Open|SpeedShop.&nbsp;&nbsp; This script can be found in the
subdirectory (from top of tree)
"plugins/panels/TemplatePanel".&nbsp;&nbsp; A "README" file in that
same directory gives "mknewpanel" usage information.&nbsp;&nbsp; The
same information can be obtained by running the "mknewpanel" script
without any arguments.&nbsp; The script modifies the TemplatePanel
sources in the TemplatePanel directory and creates a new subdirectory
under "plugins/panels" using the information given to it by the plugin
developer running the script.&nbsp;&nbsp; <br>
<br>
Here is the example output from the "mknewpanel" script creating a
Panel named "Test Panel" that will appear under the Performance menu in
Open|SpeedShop.&nbsp; Note that the initial execution of the Linux
command "ls" on the "plugins/panels" directory shows no directory named
"TestPanel".<br>
$ ls ..<br>
CmdPanel&nbsp;&nbsp; FPE_TracingPanel&nbsp;
Makefile&nbsp;&nbsp;&nbsp;&nbsp; ManageProcessesPanel&nbsp;
mysed&nbsp;&nbsp; StatsPanel<br>
CustomExperimentPanel&nbsp; HW_CounterPanel&nbsp;&nbsp;
Makefile.am&nbsp; MPIPanel&nbsp;&nbsp;&nbsp; pcSamplePanel&nbsp;
TemplatePanel<br>
DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile.in&nbsp;
mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
<br>
Now we run the "./mknewpanel" script which creates the TestPanel
subdirectory in "plugins/panels".<br>
<br>
$&nbsp; ./mknewpanel ../TestPanel TestPanel TestPanel "Test Panel"
"Cntrl B" 1 Performance<br>
PANEL_DIR=../TestPanel<br>
PANEL_NAME=TestPanel<br>
MENU_HEADING=TestPanel<br>
MENU_LABEL=Test Panel<br>
MENU_ACCEL=Cntrl B<br>
SHOW_IMMEDIATE=Performance<br>
PLUGIN_GROUPING=Performance<br>
Preparing to create your new TestPanel files.<br>
Succeeded: Finished creating files in ../TestPanel.<br>
You'll now need to edit the panels/Makefile.am to add this new
directory to the build list.<br>
You'll also need to modify the top level configure.ac file to add the
new directory to the list of directories to have makefiles created.<br>
<br>
When we do a "ls" Linux command for the "plugins/panels" directory we
now see a ""TestPanel subdirectory has been created.<br>
$ ls ..<br>
CmdPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HW_CounterPanel&nbsp;
Makefile.in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mysed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
TemplatePanel<br>
CustomExperimentPanel&nbsp;
IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ManageProcessesPanel&nbsp; pcSamplePanel&nbsp; <span
 style="font-weight: bold;">TestPanel</span><br>
DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MPIPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
FPE_TracingPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Makefile.am&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
StatsPanel<br>
<br>
Doing a list of the files in the "TestPanel" subdirectory, we see that
the "mknewpanel" script has modified the "TemplatePanel" template code
and created similar files but renamed "TestPanel".<br>
<br>
Once the GUI plugin developer
modifies Open|SpeedShop's "configure.ac" (both in the top source
directory) and "Makefile.am" (in plugins/panels directory) files to
include the newly created panels and rebuilds Open|SpeedShop, the menu
item representing the panel
will be displayed under the menu that the GUI plugin developer provided
to the mknewpanel script.&nbsp;&nbsp; <br>
<ul>
  <li>In "configure.ac" add the
directory path to the newly created GUI plugin anywhere after the list
of "plugins/panels/&lt;panel name&gt;/Makefile"
entries.&nbsp;&nbsp; In this example, add
"plugins/panels/TestPanel/Makefile". <br>
  </li>
  <li>In "Makefile.am" add the name of the newly
created GUI plugin panel directory into the "SUBDIRS" list.</li>
</ul>
<br>
<br>
<br>
<h3><a class="mozTocH3" name="mozTocId963628"></a><a
 name="Interfacing_With_OpenSpeedShop_-_Tips"></a>Interfacing With
Open|SpeedShop - Tips and Example Information</h3>
<br>
<br>
<br>
<h3><a class="mozTocH3" name="mozTocId175785"></a><a
 name="Example_Graphical_User_Interface_Plugin"></a>Example Graphical
User Interface Plugin</h3>
<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId1574"></a>Command Line
Interface Plugin Information<br>
</h2>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
