Index: libopenss-framework/BFDSymbols.cxx
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-framework/BFDSymbols.cxx,v
retrieving revision 1.10
diff -u -a -u -r1.10 BFDSymbols.cxx
--- libopenss-framework/BFDSymbols.cxx	18 Dec 2008 04:58:17 -0000	1.10
+++ libopenss-framework/BFDSymbols.cxx	26 Mar 2009 19:19:23 -0000
@@ -540,6 +540,7 @@
 	    AddressRange frange(real_begin,
 				Address(base + f_end - 1 ));
 
+#if 0
 	    for (unsigned int ii = 0; ii < addrvec.size(); ii++) {
 		// To improve performance of this search,
 		// see if one of the found functions already
@@ -602,6 +603,19 @@
 		    break;
 		}
 	    } // end for addrvec
+#endif
+
+//DEBUG
+#if 0
+std::cerr << "functions_vec.push_back : " << symname << " " << frange
+	<< " _BASE: " << Address(frange.getBegin() - base)
+	<< ":" << Address(frange.getEnd() - base)
+	<< " OBJR: "  << range_in_this_obj << std::endl;
+#endif
+		    functions_vec.push_back( BFDFunction(symname,
+							  frange.getBegin().getValue(),
+							  frange.getEnd().getValue())
+						);
 	}
 
 	// If all addresses have been resolved, terminate search.
@@ -793,7 +807,8 @@
 
 int
 BFDSymbols::getBFDFunctionStatements(PCBuffer *addrbuf,
-				     LinkedObject* linkedobject)
+				     LinkedObject* linkedobject,
+				     SymbolTableMap& st)
 {
     int rval = -1;
     init_done = 0;
@@ -822,7 +837,8 @@
 		  << filename << std::endl;
 	return rval;
     }
-
+ 
+    int addresses_found = 0;
     bfd_vma loadaddr = 0;
     bfd_vma endaddr = 0;
     std::set<AddressRange>::iterator si;
@@ -836,7 +852,6 @@
 #endif
 	loadaddr=(*si).getBegin().getValue();
 	endaddr=(*si).getEnd().getValue();
-    }
 
 
     std::vector<uint64_t> addrvec;
@@ -865,7 +880,7 @@
 
     // foreach address in addrvec, find the function, file, line number.
     // See find_address_in_section for details.
-    int addresses_found = 0;
+    addresses_found = 0;
     int addresses_notfound = 0;
 
     // store functions begin and end address for functions with found
@@ -926,6 +941,8 @@
         bfd_map_over_sections (theBFD, find_address_in_section, NULL);
     }
 
+    }
+
     if (syms) {
 	free(syms);
 	syms = NULL;
Index: libopenss-framework/BFDSymbols.hxx
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-framework/BFDSymbols.hxx,v
retrieving revision 1.2
diff -u -a -u -r1.2 BFDSymbols.hxx
--- libopenss-framework/BFDSymbols.hxx	11 Nov 2008 22:03:27 -0000	1.2
+++ libopenss-framework/BFDSymbols.hxx	26 Mar 2009 19:19:23 -0000
@@ -1,6 +1,7 @@
 #include <bfd.h>
 #include <stdint.h>
 #include "ToolAPI.hxx"
+#include "OfflineExperiment.hxx"
 #include "LinkedObject.hxx"
 
 namespace OpenSpeedShop { namespace Framework {
@@ -59,7 +60,8 @@
     FunctionsVec  bfd_functions;
     StatementsVec bfd_statements;
 
-    int		getBFDFunctionStatements(PCBuffer*, LinkedObject*);
+    int		getBFDFunctionStatements(PCBuffer*, LinkedObject*,
+					 SymbolTableMap&);
     int		getFunctionSyms(PCBuffer*, FunctionsVec&, bfd_vma, bfd_vma);
     int		initBFD(std::string);
     Path	getObjectFile(Path);
Index: libopenss-framework/OfflineExperiment.cxx
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-framework/OfflineExperiment.cxx,v
retrieving revision 1.15
diff -u -a -u -r1.15 OfflineExperiment.cxx
--- libopenss-framework/OfflineExperiment.cxx	27 Jan 2009 23:16:51 -0000	1.15
+++ libopenss-framework/OfflineExperiment.cxx	26 Mar 2009 19:19:23 -0000
@@ -1,5 +1,5 @@
 ////////////////////////////////////////////////////////////////////////////////
-// Copyright (c) 2008 The Krell Institute. All Rights Reserved.
+// Copyright (c) 2008,2009 The Krell Institute. All Rights Reserved.
 //
 // This library is free software; you can redistribute it and/or modify it under
 // the terms of the GNU Lesser General Public License as published by the Free
@@ -33,6 +33,9 @@
 #include "Blob.hxx"
 #include "BFDSymbols.hxx"
 #include "ThreadName.hxx"
+#include "SymtabAPISymbols.hxx"
+#include "Symtab.h"
+
 #include <algorithm>
 
 #include <iostream>
@@ -48,10 +51,40 @@
 using namespace OpenSpeedShop::Framework;
 
 namespace {
-static   PCBuffer data_addr_buffer;
+    struct DsoEntry
+    {
+
+    /** Full path name of this linked object. */
+    Path dso_path;
+
+    /** Flag indicating if this linked object is an executable. */
+    std::string dso_host;
+    int  dso_pid;
+    uint64_t dso_tid;
+    AddressRange dso_range;
+    TimeInterval dso_time;
+    int dso_dlopen;
+
+    /** Constructor from fields. */
+    DsoEntry(const Path& path, const std::string host, const int& pid,
+	     const uint64_t& tid, const AddressRange& range,
+	     const TimeInterval& time, const int& is_dlopen) :
+	dso_path(path),
+	dso_host(host),
+	dso_pid(pid),
+	dso_tid(tid),
+	dso_range(range),
+	dso_time(time),
+	dso_dlopen(is_dlopen)
+	{ }
+    };
+
+    typedef  std::vector<DsoEntry> DsoVec;
+    static   PCBuffer data_addr_buffer;
+    SymbolTable* symtabapi_symtab;
+    DsoVec dsoVec;
 };
 
-std::map<AddressRange, std::set<LinkedObject> > global_needed;
 
 #ifndef NDEBUG
 /** Flag indicating if debuging for MPI jobs is enabled. */
@@ -308,7 +341,7 @@
 
     std::set<std::string>::iterator ssi,ssii, temp;
     for( ssi = executables_used.begin(); ssi != executables_used.end(); ++ssi) {
-	std::cerr << "Processing raw data for " << (*ssi) << std::endl;
+	std::cerr << "Processing raw experiment data for " << (*ssi) << std::endl;
         for( ssii = dataList.begin(); ssii != dataList.end(); ++ssii) {
 	    if( (*ssii).find((*ssi)) != string::npos) {
 		rawfiles.push_back((*ssii));
@@ -359,6 +392,9 @@
 {
     std::string rawname;
 
+    std::cout << "Adding process and thread information to "
+	      << theExperiment->getName() << std::endl;
+
     // process offline info blobs first.
     for (unsigned int i = 0;i < rawfiles.size();++i) {
 	bool_t found_infofile = false;
@@ -489,6 +525,10 @@
     // linked objects, addressspaces, files, functions, statements
     // where performance data was collected.
 
+
+    std::cout << "Adding sample address data to "
+	      << theExperiment->getName() << std::endl;
+
     for (unsigned int i = 0;i < rawfiles.size();i++) {
 	bool_t found_datafile = false;
 	if (rawfiles[i].find(".openss-data") != string::npos) {
@@ -533,7 +573,7 @@
  * by the either a string of data blobs or dso blobs and data blobs
  * the are intermixed.
  * Each blob will have a header and the actual blob data.
- * For an experiment info blob, this the usual header and an
+ * For an experiment info blob, this is the usual header and an
  * expinfo blob as described by the runtime's offline.x file.
  */
 
@@ -643,8 +683,12 @@
 	    break;
 	}
 
+#if 1
 	char *theData;
 	theData = (char *) malloc (blobsize+4);
+#else
+	char *theData = (char*)alloca(blobsize+4);
+#endif
 	if (theData == 0) {
 	    std::cerr << "Could Not allocate memory for data!" << std::endl;
 	    fclose(f);
@@ -665,9 +709,11 @@
 	DataQueues::enqueuePerformanceData(datablob);
 	theExperiment->flushPerformanceData();
 
+#if 1
 	if (theData) {
 	    free(theData);
 	}
+#endif
 
     } // while
 
@@ -753,16 +799,31 @@
 	    // Skip any vdso or vsyscall entry from /proc/self/maps.
             if ( objname.find("[vdso]") == string::npos &&
                  objname.find("[vsyscall]") == string::npos &&
+                 objname.find("[stack]") == string::npos &&
 		 objname.compare("unknown") != 0 ) {
+
                 names_to_range.push_back(std::make_pair(objname,range));
                 names_to_time.push_back(std::make_pair(objname,time_interval));
+
+		DsoEntry e(objname,objsheader.host, objsheader.pid,
+			   objsheader.posix_tid, range,time_interval,
+			   objs.is_open);
+		dsoVec.push_back(e);
+//DEBUG
+#ifndef NDEBUG
+		if(is_debug_offline_enabled) {
+		    std::cout << "dsoVec inserts " << objname << ", " << range
+		    << ", " << objsheader.host << ":"
+		    << objsheader.pid << ":" << objsheader.posix_tid << std::endl;
+		}
+#endif
             }
 
 //DEBUG
 #ifndef NDEBUG
 	    if(is_debug_offline_enabled) {
 		std::cout << "range for " << objs.objname << " is"
-		  << range <<  " is dlopen " << objs.is_open << std::endl;
+		  << range <<  " is dlopen " << (int) objs.is_open << std::endl;
 
 		std::cout << "objectsheader..." << std::endl
 		  << "experiment id:  " << objsheader.experiment << std::endl
@@ -804,20 +865,13 @@
 
 
     // Find current threads used in this experiment.
-    ThreadGroup threads;
-    ThreadGroup original = theExperiment->getThreads();
-
-    // Find any new threads.
-    insert_iterator< ThreadGroup > ii( threads, threads.begin() );
-    std::set_difference(original.begin(), original.end(),
-			threads_processed.begin(), threads_processed.end(),
-			ii);
+    ThreadGroup threads = theExperiment->getThreads();
 
 // DEBUG
 #ifndef NDEBUG
     if(is_debug_offlinesymbols_enabled) {
         std::cerr << "OfflineExperiment::createOfflineSymbolTable have total "
-	<< original.size() << " threads" << std::endl;
+	<< threads.size() << " threads" << std::endl;
 
         for(ThreadGroup::const_iterator ni = threads.begin();
 				    ni != threads.end(); ++ni) {
@@ -828,18 +882,12 @@
     }
 #endif
 
-    // add any new threads to threads_processed group.
-    // the new threads will be processed below.
-    insert_iterator< ThreadGroup > iu( threads_processed,
-					threads_processed.begin() );
-    std::set_union(original.begin(), original.end(),
-			threads.begin(), threads.end(),
-			iu);
-
     if (threads.size() == 0) {
 	return;
     }
 
+    std::cout << "Adding symbols to " << theExperiment->getName() << std::endl;
+
     // Create an Extent from this experiments performance data.
     Extent e = theExperiment->getPerformanceDataExtent();
 
@@ -848,6 +896,8 @@
 
     CollectorGroup cgrp = theExperiment->getCollectors();
 
+    SymtabAPISymbols stapiSyms;
+
     // Find the unique address values collected for this experiment
     // from all threads for the current executable being processed.
     // For mpi jobs we group threads to a specific executable.
@@ -872,266 +922,140 @@
 	    // for this thread group.
 	    c.getUniquePCValues(*i,eg,&data_addr_buffer);
 	}
-    }
 
-// DEBUG
-#ifndef NDEBUG
-    if(is_debug_offlinesymbols_enabled) {
-        std::cerr << "OfflineExperiment::createOfflineSymbolTable have total "
-	<< data_addr_buffer.length << " UNIQUE addresses" << std::endl;
-    }
-#endif
+	AddressSpace taddress_space;
 
-    std::set<std::string> dsos_used;
-    AddressSpace address_space;
-
-    for (unsigned i = 0; i < data_addr_buffer.length; i++) {
- 	Address addr = Address(data_addr_buffer.pc[i]);
-
-	// create list of dso's for which there is an address in the performance
-	// data. Update database address_space with threads and linked objects.
-	// Mark the executable (is_executable = true, shared librarys = false).
-	for(std::vector<std::pair<std::string, AddressRange> >::iterator
-              j = names_to_range.begin(); j != names_to_range.end(); ++j) {
-
-	    bool_t range_found = false;
-	    if (j->second.doesContain(addr) && !range_found) {
-
-		    dsos_used.insert(j->first);
-		    bool is_exe = false;
-
-                    std::set<std::string>::iterator exei =
-                                expExecutableName.find(j->first);
-                    if(exei != expExecutableName.end()) {
-                        is_exe = true;
-                    }
 // DEBUG
 #ifndef NDEBUG
-		    if(is_debug_offline_enabled) {
-		      std::cerr << "OfflineExperiment::createOfflineSymbolTable:"
-			<< " Added " << j->first
-			<< " to linkedobjects table, is executable "
-			<< is_exe << std::endl;
-		    }
-#endif
-		    address_space.setValue(j->second, j->first,
-					   /*is_executable*/ is_exe);
-	    }
-	} 
-    }
-
-    // Some executables may not contribute a sample while one of their
-    // shared libraries may.  We always want the executable present
-    // in the database symbols.
-    for(std::vector<std::pair<std::string, AddressRange> >::iterator
-              j = names_to_range.begin(); j != names_to_range.end(); ++j) {
-	if (dsos_used.find(j->first) == dsos_used.end()) {
-	    dsos_used.insert(j->first);
-	    std::set<std::string>::iterator exei = expExecutableName.find(j->first);
-	    if (exei != expExecutableName.end()) {
-		address_space.setValue(j->second, j->first, true);
-	    }
+	if(is_debug_offlinesymbols_enabled) {
+	    std::cerr << "OfflineExperiment::createOfflineSymbolTable "
+	     << "set address space for " << (*i).getProcessId() << std::endl;
 	}
-    }
-
-    Time when;
-    for(std::vector<std::pair<std::string, TimeInterval> >::iterator
-              j = names_to_time.begin(); j != names_to_time.end(); ++j) {
-	when = j->second.getBegin();
-	break;
-    }
-
-    // creates empty symboltable for these.
-    // Apparently, all symboltable seem to have Time::TheBegining
-    // as the load begin time.
-    // This updateThreads call will update the addressspace, linkedobjects,
-    // and files tables in the database. We do not use returned map
-    // of needed symboltables since some of the existing symboltables
-    // may also be used by the current executable (if more than one
-    // executable contributes data for this experiment - e.g. mpi).
-    std::map<AddressRange, std::set<LinkedObject> > tneeded =
-    address_space.updateThreads(threads, when,
-				/*update_time_interval*/ false);
-
-// FUTURE call in AddressSpace class to set time_begin for
-// addressspaces.  The offline rawdata conversion tool will
-// use this to ensure that the time stamp when linked object
-// is loaded will be set correctly in the database.
-// Currently updateThreads does not do this for offline.
-#if 0
-    address_space.updateThreadsTimeBegin(threads, when);
-#endif
-
-    // For the conventional dpcl/mrnet dynamic instrumentors the
-    // AddressSpace::updateThreads call will return only those
-    // symboltables that where not previously built.  This is
-    // expected for dpcl/mrnet since ALL symbols are parsed and
-    // added to the database when first see a linked object.
-    //
-    // For offline experiments, we post process symbols according
-    // to performance data sample addresses. Therfore we can not
-    // assume any previously seen symboltables where completey built.
-    // In the case of openmpi, the orterun (mpirun) process may
-    // be first processed for symbols and creates entries in the
-    // database for any number of linked objects.  When we parse the
-    // mpi application later, AddressSpace::updateThreads assumes
-    // we have already gotten symbols for dsos like libc.so which
-    // was parsed previously by orterun and therefore would skip
-    // such dsos even though we may have new function addresses
-    // from the mpi aplication with in a previously see dso.
-    //
-    // The following code creates a map of address ranges and
-    // linkedobjects based on performance data sample addresses.
-    // We still need to call AddressSpace::updateThreads prior to
-    // this to update the database addressspace, file, linkedobects
-    // tables.
-    std::map<AddressRange, std::set<LinkedObject> > needed; 
-
-    // Find all linkedobjects for the current threadgroup.
-    std::set<LinkedObject> objects = threads.getLinkedObjects();
-    for(std::set<LinkedObject>::const_iterator li = objects.begin();
-				    li != objects.end(); ++li) {
-
-
-	// Find addressranges for this linked object.
-	std::set<AddressRange> obj_range = (*li).getAddressRange();
-	for(std::set<AddressRange>::const_iterator obj_ar = obj_range.begin();
-		obj_ar != obj_range.end(); ++obj_ar) {
-
-	    for(std::vector<std::pair<std::string, AddressRange> >::iterator
-           		nr = names_to_range.begin();
-			nr != names_to_range.end();
-			++nr) {
-
-		// See if this linked object is found in our list of
-		// dsos and addressranges for the current executable,
-		if ((*nr).second.doesContain(*obj_ar) &&
-			(*nr).first == (*li).getPath() ) {
-
-// DEBUG
-#ifndef NDEBUG
-		    if(is_debug_offline_enabled) {
-			std::cerr
-			<< "OfflineExperiment::createOfflineSymbolTable "
-			<< " linked object " << (*li).getPath()
-			<< " contains " << (*obj_ar) << std::endl;
-		    }
 #endif
 
-		    std::map<AddressRange, std::set<LinkedObject> >::iterator
-			ni = needed.insert( std::make_pair( (*obj_ar),
-					    std::set<LinkedObject>())).first;
-
-		    ni->second.insert(*li);
-		    // FOUND IT.  stop looking.
-		    break;
+	for(DsoVec::const_iterator d=dsoVec.begin(); d != dsoVec.end(); ++d) {
+	    if ((*i).getProcessId() == d->dso_pid ) {
+		bool is_exe = false;
+
+		std::set<std::string>::iterator exei =
+					expExecutableName.find(d->dso_path);
+		if(exei != expExecutableName.end()) {
+		    is_exe = true;
 		}
+
+		AddressRange drange(d->dso_range);
+		taddress_space.setValue(drange, d->dso_path,
+					/*is_executable*/ is_exe);
 	    }
 	}
-    }
 
-    // Iterate over each needed symbol table for this address space
-    for(std::map<AddressRange, std::set<LinkedObject> >::const_iterator
-	    t = needed.begin(); t != needed.end(); ++t) {
+	ThreadGroup stthreads;
+	stthreads.insert(*i);
+	std::map<AddressRange, std::set<LinkedObject> > tneeded =
+			taddress_space.updateThreads(stthreads, Time::TheEnd(),
+			/*update_time_interval*/ false);
 
-// DEBUG
-#ifndef NDEBUG
-	if(is_debug_offlinesymbols_enabled) {
-	    for (std::set<LinkedObject>::const_iterator
-		    l = t->second.begin(); l != t->second.end(); ++l) {
-	        std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-	        << " INSERT SYMTAB for " <<  (*l).getPath()
-	        << " RANGE " << t->first
-	        << " AT TIME " << when
-	        << std::endl;
-	    }
+	for(std::map<AddressRange, std::set<LinkedObject> >::const_iterator
+		t = tneeded.begin(); t != tneeded.end(); ++t) {
+	    // Add an empty symbol table to the state for this address range
+	    symtabmap.insert(std::make_pair(t->first,
+			     std::make_pair(SymbolTable(t->first), t->second))
+			    );
 	}
-#endif
-
-	// Add an empty symbol table to the state for this address range
-	symtabmap.insert( std::make_pair(t->first,
-			  std::make_pair(SymbolTable(t->first), t->second))
-			);
     }
 
-    int addresses_found =-1;
+for (unsigned ii = 0; ii < data_addr_buffer.length; ii++) {
+std::cerr  << "createOfflineSymbolTable: data_addr_buffer[" << ii
+	<< "]" << Address(data_addr_buffer.pc[ii]) << std::endl;
+}
+
+    std::set<LinkedObject> ttgrp_lo = threads.getLinkedObjects();
+    for(std::set<LinkedObject>::const_iterator j = ttgrp_lo.begin();
+					       j != ttgrp_lo.end(); ++j) {
+	LinkedObject lo = (*j);
+	std::set<AddressRange> lorange = lo.getAddressRange();
+	std::set<AddressRange>::iterator si;
+	for(si = lorange.begin() ; si != lorange.end(); ++si) {
+	    AddressRange lrange;
+	    lrange = (*si);
+std::cerr  << "createOfflineSymbolTable: RESOLVING LO " << lo.getPath()
+	<< ":" << lrange << std::endl;
+	    if (symtabmap.find(*si) != symtabmap.end()) {
+		SymbolTable st =  symtabmap.find(*si)->second.first;
+#if 1
+		stapiSyms.getSymbols(lo,symtabmap);
+#else
+    		BFDSymbols mybfd_symbols;
+
+                int addresses_found =
+		mybfd_symbols.getBFDFunctionStatements(&data_addr_buffer, &lo,
+						     symtabmap);
+
+		FunctionsWithData = mybfd_symbols.bfd_functions;
  
-    // TODO: Make this configurable for use with symtabAPI from dyninst.
-    // Using bfd to find symbols.
-    // Foreach linked object we find that has pc data,
-    // pass the buffer of sampled addresses to getBFDFunctionStatements
-    // and resolve function and statement symbols.
-    std::set<LinkedObject> tgrp_lo = threads.getLinkedObjects();
-    for(std::set<LinkedObject>::const_iterator j = tgrp_lo.begin();
-		j != tgrp_lo.end(); ++j) {
-	    LinkedObject lo = (*j);
-            addresses_found =
-		bfd_symbols.getBFDFunctionStatements(&data_addr_buffer, &lo);
-    }
+		// Add Functions
+		// RESTRICT functions to only those with sampled addresses.
+		int functionsadded = 0;
+		for(FunctionsVec::iterator f = FunctionsWithData.begin();
+                    f != FunctionsWithData.end(); ++f) {
+
+		    AddressRange frange(f->getFuncBegin(),f->getFuncEnd());
 
-    FunctionsWithData = bfd_symbols.bfd_functions;
-    StatementsWithData =  bfd_symbols.bfd_statements;
+std::cerr << "createOfflineSymbolTable: EXAMINING " << f->getFuncName()
+	<< ":" << frange << std::endl;
 
+		    if (symtabmap.find(frange) != symtabmap.end()) {
+			SymbolTable& symbol_table =
+				symtabmap.find(frange)->second.first;
+			Address start = f->getFuncBegin();
+			Address end = f->getFuncEnd();
 // DEBUG
 #ifndef NDEBUG
-    if(is_debug_offline_enabled) {
-      std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-	<< " getBFDFunctionStatements found functions for " << addresses_found
-	<< " sample addresses from total "
-	<< data_addr_buffer.length << std::endl;
-
-      std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-	<< " Functions with DATA: " << FunctionsWithData.size()
-	<< std::endl;
-      std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-	<< " StatementsWithData with DATA: " << StatementsWithData.size()
-	<< std::endl;
-    }
-#endif
+			if(is_debug_offlinesymbols_enabled) {
 
-    // Add Functions
-    // RESTRICT functions to only those with sampled addresses.
-    int functionsadded = 0;
-    for(FunctionsVec::iterator f = FunctionsWithData.begin();
-                    f != FunctionsWithData.end(); ++f) {
-	AddressRange frange(f->getFuncBegin(),f->getFuncEnd());
-        if (symtabmap.find(frange) != symtabmap.end()) {
-	    SymbolTable& symbol_table =  symtabmap.find(frange)->second.first;
-	    Address start = f->getFuncBegin();
-	    Address end = f->getFuncEnd();
+			std::cerr
+			<< "OfflineExperiment::createOfflineSymbolTable: "
+			<< "ADDING FUNCTION for " << f->getFuncName()
+			<< " with range " << frange << std::endl;
+
+			}
+#endif
+			symbol_table.addFunction(start, end, f->getFuncName());
+			functionsadded++;
+		    } else {
 // DEBUG
 #ifndef NDEBUG
-	    if(is_debug_offline_enabled) {
-              std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-		<< "ADDING FUNCTION for " << f->getFuncName()
-		<< " with range " << frange << std::endl;
-	    }
+			if(is_debug_offlinesymbols_enabled) {
+			std::cerr
+			<< "OfflineExperiment::createOfflineSymbolTable: "
+			<< "FAILED FUNCTION for " << f->getFuncName()
+			<< " with range " << frange << std::endl;
+
+			}
 #endif
-	    symbol_table.addFunction(start, end, f->getFuncName());
-	    functionsadded++;
-	} else {
-              std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-		<< "FAILED FUNCTION for " << f->getFuncName()
-		<< " with range " << frange << std::endl;
-	}
-    }
+		    }
+		}
 
-    // Add Statements
-    // RESTRICT statement to only those with sampled addresses.
-    int statementsadded = 0;
-    for(StatementsVec::iterator objsyms = StatementsWithData.begin() ;
-	objsyms != StatementsWithData.end(); ++objsyms) {
-      AddressRange frange(objsyms->pc,objsyms->pc+1);
-      if (symtabmap.find(frange) != symtabmap.end()) {
-	SymbolTable& symbol_table =  symtabmap.find(frange)->second.first;
-	Address s_begin = objsyms->pc;
-	Address s_end = objsyms->pc + 1;
-	std::string path = objsyms->file_name;
-	unsigned int line = objsyms->lineno;
-	unsigned int col = 0;
+		StatementsWithData =  mybfd_symbols.bfd_statements;
+		// Add Statements
+		// RESTRICT statement to only those with sampled addresses.
+		int statementsadded = 0;
+		for(StatementsVec::iterator objsyms = StatementsWithData.begin() ;
+		    objsyms != StatementsWithData.end(); ++objsyms) {
+
+		    AddressRange frange(objsyms->pc,objsyms->pc+1);
+
+		    if (symtabmap.find(frange) != symtabmap.end()) {
+			SymbolTable& symbol_table =
+				symtabmap.find(frange)->second.first;
+			Address s_begin = objsyms->pc;
+			Address s_end = objsyms->pc + 1;
+			std::string path = objsyms->file_name;
+			unsigned int line = objsyms->lineno;
+			unsigned int col = 0;
 // DEBUG
 #ifndef NDEBUG
-	if(is_debug_offline_enabled) {
+	if(is_debug_offlinesymbols_enabled) {
             std::cerr << "OfflineExperiment::createOfflineSymbolTable"
 		<< " ADDING STATEMENT for " << Address(objsyms->pc)
 		<< " with path " << path
@@ -1139,24 +1063,33 @@
 		<< std::endl;
 	}
 #endif
-	if (path.size() != 0) {
-	    symbol_table.addStatement(s_begin,s_end,path,line,col);
-	    statementsadded++;
-	} else {
-	}
-      } else {
-              std::cerr << "OfflineExperiment::createOfflineSymbolTable: "
-		<< "FAILED STATEMENT for " << Address(objsyms->pc)
-		<< " path " << objsyms->file_name
-		<< " line " << objsyms->lineno
-		<< std::endl;
-      }
-    }
 
-    std::cerr << "Added " << functionsadded
-	<< " functions to symboltable" << std::endl;
-    std::cerr << "Added " << statementsadded
-	<< " statements to symboltable" << std::endl;
+			if (path.size() != 0) {
+			    symbol_table.addStatement(s_begin,s_end,
+						      path,line,col);
+			    statementsadded++;
+			} else {
+			}
+
+		    } else {
+// DEBUG
+#ifndef NDEBUG
+	if(is_debug_offlinesymbols_enabled) {
+                      std::cerr
+			<< "OfflineExperiment::createOfflineSymbolTable: "
+		        << "FAILED STATEMENT for " << Address(objsyms->pc)
+		        << " path " << objsyms->file_name
+		        << " line " << objsyms->lineno
+		        << std::endl;
+
+	}
+#endif
+		    }
+		}
+#endif
+	    }
+	}
+    }
 
     // Now update the database with all our functions and statements...
     for(SymbolTableMap::iterator i = symtabmap.begin();
@@ -1169,7 +1102,5 @@
         }
     }
 
-    // clear names to range for our next linked object.
-    names_to_range.clear();
-    names_to_time.clear();
+    return;
 }
Index: libopenss-runtime/OpenSS_FPEHandler.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-runtime/OpenSS_FPEHandler.c,v
retrieving revision 1.6
diff -u -a -u -r1.6 OpenSS_FPEHandler.c
--- libopenss-runtime/OpenSS_FPEHandler.c	27 Jan 2009 23:16:51 -0000	1.6
+++ libopenss-runtime/OpenSS_FPEHandler.c	26 Mar 2009 19:19:23 -0000
@@ -86,7 +86,7 @@
  */
 static void signalHandler(int signal, siginfo_t* info, void* ptr)
 {
-fprintf(stderr,"ENTERED FPE signalHandler with signal %d\n",signal);
+fprintf(stderr,"ENTERED FPE signalHandler with signal %d, code %d\n",signal, info->si_code);
 
     OpenSS_FPEType fpe_type = Unknown;
 
@@ -102,26 +102,33 @@
     if(tls->fpe_handler != NULL) {
 	switch (info->si_code) {
 	case FPE_FLTDIV:
+	    fprintf(stderr,"signalHandler DivideByZero\n");
 	    fpe_type = DivideByZero;
 	    break;
 	case FPE_FLTOVF:
+	    fprintf(stderr,"signalHandler Overflow\n");
 	    fpe_type = Overflow;
 	    break;
 	case FPE_FLTUND:
+	    fprintf(stderr,"signalHandler Underflow\n");
 	    fpe_type = Underflow;
 	    break;
 	case FPE_FLTRES:
+	    fprintf(stderr,"signalHandler InexactResult\n");
 	    fpe_type = InexactResult;
 	    break;
 	case FPE_FLTINV:
+	    fprintf(stderr,"signalHandler InvalidOperation\n");
 	    fpe_type = InvalidOperation;
 	    break;
 	case FPE_FLTSUB:
+	    fprintf(stderr,"signalHandler SubscriptOutOfRange\n");
 	    fpe_type = SubscriptOutOfRange;
 	    break;
 	case FPE_INTDIV:  /* Ignored: integer divide by zero */
 	case FPE_INTOVF:  /* Ignored: integer overflow */
 	default:
+	    fprintf(stderr,"signalHandler DEFAULT UNKNOWN\n");
 	    fpe_type = Unknown;
 	    break;
 	}
Index: libopenss-runtime/OpenSS_GetStackTraceFromContext.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-runtime/OpenSS_GetStackTraceFromContext.c,v
retrieving revision 1.7
diff -u -a -u -r1.7 OpenSS_GetStackTraceFromContext.c
--- libopenss-runtime/OpenSS_GetStackTraceFromContext.c	30 Jul 2008 16:47:09 -0000	1.7
+++ libopenss-runtime/OpenSS_GetStackTraceFromContext.c	26 Mar 2009 19:19:23 -0000
@@ -63,6 +63,7 @@
 				     unsigned* stacktrace_size,
 				     uint64_t* stacktrace)
 {
+//fprintf(stderr,"ENTERED OpenSS_GetStackTraceFromContext %d\n",getpid());
     unw_context_t context;
     unw_cursor_t cursor;
     int retval;
@@ -76,7 +77,8 @@
      * thread context directly.
      */
     if(signal_context != NULL) {
-	memcpy(&context, signal_context, sizeof(unw_context_t));
+	//memcpy(&context, signal_context, sizeof(unw_context_t));
+	memmove(&context, signal_context, sizeof(unw_context_t));
 	skip_signal_frames = FALSE;
     }
     else
@@ -127,6 +129,7 @@
 	}
 	
 	/* Unwind to the next frame, stopping after the last frame */
+//fprintf(stderr,"OpenSS_GetStackTraceFromContext about to unw_step %d\n",getpid());
 	retval = unw_step(&cursor);
 	if(retval <= 0)
 	    break;
@@ -135,4 +138,5 @@
     
     /* Return the stack trace size to the caller */
     *stacktrace_size = index;
+//fprintf(stderr,"EXIT OpenSS_GetStackTraceFromContext %d\n",getpid());
 }
Index: libopenss-runtime/offline/offline_monitor.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/libopenss-runtime/offline/offline_monitor.c,v
retrieving revision 1.9
diff -u -a -u -r1.9 offline_monitor.c
--- libopenss-runtime/offline/offline_monitor.c	5 Mar 2009 21:59:29 -0000	1.9
+++ libopenss-runtime/offline/offline_monitor.c	26 Mar 2009 19:19:23 -0000
@@ -55,45 +55,72 @@
 #include "monitor.h"
 
 extern void offline_start_sampling(const char* arguments);
-extern void offline_stop_sampling(const char* arguments);
+extern void offline_stop_sampling(const char* arguments, const int finished);
 extern void offline_record_dso(const char* dsoname);
+extern void offline_defer_sampling(const int flag);
 int OpenSS_mpi_rank = -1;
+int sampling_active = 0;
+int process_is_terminating = 0;
+int thread_is_terminating = 0;
 
-#if defined(_MONITOR_H_)
-void monitor_fini_process(int how, void *data)
-#else
-void monitor_fini_process(void)
+#if 1
+#include <setjmp.h>
+sigjmp_buf unwind_jmp;
+int OpenSS_numsegv;
+int OpenSS_unwinding;
+
+int
+OpenSS_SEGVhandler(int sig, siginfo_t *siginfo, void *context)
+{
+    if (OpenSS_unwinding) {
+        OpenSS_numsegv++;
+        siglongjmp(unwind_jmp,9);
+    }
+    return 1;
+}
+
+int OpenSS_SetSEGVhandler(void)
+{
+    int rval = monitor_sigaction(SIGSEGV, &OpenSS_SEGVhandler, 0, NULL);
+
+    if (rval != 0) {
+        fprintf(stderr,"Unable to install SIGSEGV handler", __FILE__, __LINE__);
+    }
+
+    return rval;
+}
 #endif
+
+/*
+ * callbacks for handling of PROCESS
+ */
+void monitor_fini_process(int how, void *data)
 {
-#if 0
+    /*collector stop_sampling does not use the arguments param */
+    //fprintf(stderr,"monitor_fini_process STOP SAMPLING %d\n",getpid());
     static int f = 0;
     if (f > 0)
       raise(SIGSEGV);
     f++;
-#endif
-
-    /*collector stop_sampling does not use the arguments param */
-    offline_stop_sampling(NULL);
+    sampling_active = 0;
+    process_is_terminating = 1;
+    offline_stop_sampling(NULL, 1);
     OpenSS_mpi_rank = monitor_mpi_comm_rank();
-    //fprintf(stderr,"OPENSS monitor_fini_process callback: OpenSS_mpi_rank = %d\n",
-    //OpenSS_mpi_rank);
 }
 
-#if defined(_MONITOR_H_)
 void *monitor_init_process(int *argc, char **argv, void *data)
-#else
-void monitor_init_process(char *process, int *argc, char **argv, unsigned pid)
-#endif
 {
+    //fprintf(stderr,"monitor_init_process START SAMPLING %d\n",getpid());
+    sampling_active = 1;
     offline_start_sampling(NULL);
-    return data;
+    return (data);
 }
 
+/*
+ * callbacks for handling of monitor init
+ */
 void monitor_init_library(void)
 {
-/* removed previous code that was specific to UTK monitor and
- * only used for debug error checking
- */
 }
 
 void monitor_fini_library(void)
@@ -104,21 +131,23 @@
     f++;
 }
 
+/*
+ * callbacks for handling of THREADS
+ */
 void monitor_fini_thread(void *ptr)
 {
-    offline_stop_sampling(NULL);
+    //fprintf(stderr,"monitor_fini_thread STOP SAMPLING %d\n",getpid());
+    sampling_active = 0;
+    thread_is_terminating = 1;
+    offline_stop_sampling(NULL,1);
     OpenSS_mpi_rank = monitor_mpi_comm_rank();
-    //fprintf(stderr,"OPENSS monitor_fini_process callback: OpenSS_mpi_rank = %d\n",
-    //OpenSS_mpi_rank);
     return (ptr);
 }
 
-#if defined(_MONITOR_H_)
 void *monitor_init_thread(int tid, void *data)
-#else
-void *monitor_init_thread(const unsigned tid)
-#endif
 {
+    //fprintf(stderr,"monitor_init_thread START SAMPLING %d\n",getpid());
+    sampling_active = 1;
     offline_start_sampling(NULL);
     return(data);
 }
@@ -127,43 +156,107 @@
 {
 }
 
-/* The Rice version of libmonitor added the flags adn
- * handle arguments to monitor dlopen. Use _MONITOR_H_
- * as define by Rice to determine which libmonitor
- * is being used. The UTK monitor package defines libmonitor_h
+/*
+ * callbacks for handling of DLOPEN/DLCLOSE.
  */
-#if defined(_MONITOR_H_)
 void monitor_dlopen(const char *library, int flags, void *handle)
-#else
-void monitor_dlopen(const char *library)
-#endif
 {
-    /* TODO: if OpenSS_GetDLInfo does not handle errors do so here. */
+    /* TODO:
+     * if OpenSS_GetDLInfo does not handle errors do so here.
+     */
     int retval = OpenSS_GetDLInfo(getpid(), library);
+    if (!sampling_active) {
+	//fprintf(stderr,"monitor_dlopen RESUME SAMPLING %d\n",getpid());
+	sampling_active = 1;
+	offline_start_sampling(NULL);
+    }
+}
+
+void
+monitor_pre_dlopen(const char *path, int flags)
+{
+    if (sampling_active) {
+	//fprintf(stderr,"monitor_pre_dlopen PAUSE SAMPLING %d\n",getpid());
+	sampling_active = 0;
+	offline_stop_sampling(NULL,0);
+    }
 }
 
-#if defined(_MONITOR_H_)
-/* TODO */
-/* Rice version of libmonitor.
- * callbacks for handling of fork.
+void
+monitor_dlclose(void *handle)
+{
+    if (!thread_is_terminating || !process_is_terminating) {
+	if (sampling_active) {
+	    //fprintf(stderr,"monitor_dlclose PAUSE SAMPLING %d\n",getpid());
+	    sampling_active = 0;
+	    offline_stop_sampling(NULL,0);
+	}
+    }
+}
+
+void
+monitor_post_dlclose(void *handle, int ret)
+{
+    if (!thread_is_terminating || !process_is_terminating) {
+	if (!sampling_active) {
+	    //fprintf(stderr,"monitor_post_dlclose RESUME SAMPLING %d\n",getpid());
+	    sampling_active = 1;
+	    offline_start_sampling(NULL);
+	}
+    }
+}
+
+/* 
+ * callbacks for handling of FORK.
  */
 void * monitor_pre_fork(void)
 {
-    //fprintf(stderr,"OPENSS monitor_pre_fork callback:\n");
+    /* Stop sampling prior to real fork. */
+    if (sampling_active) {
+	//fprintf(stderr,"monitor_pre_fork PAUSE SAMPLING %d\n",getpid());
+	sampling_active = 0;
+	offline_stop_sampling(NULL,1);
+    }
     return (NULL);
 }
 
 void monitor_post_fork(pid_t child, void *data)
 {
-    //fprintf(stderr,"OPENSS monitor_post_fork callback:\n");
+    /* Resume/start sampling forked process. */
+    if (!sampling_active) {
+	//fprintf(stderr,"monitor_post_fork RESUME SAMPLING %d\n",getpid());
+	sampling_active = 1;
+	offline_start_sampling(NULL);
+    }
+}
+
+/*
+ * callbacks for handling of MPI programs.
+ */
+
+void monitor_mpi_pre_init(void)
+{
+    if (sampling_active) {
+	//fprintf(stderr,"monitor_mpi_pre_init PAUSE SAMPLING %d\n",getpid());
+	sampling_active = 0;
+	offline_stop_sampling(NULL,0);
+    }
+}
+
+void
+monitor_init_mpi(int *argc, char ***argv)
+{
+    //fprintf(stderr,"ENTER monitor_init_mpi\n");
+    OpenSS_mpi_rank = monitor_mpi_comm_rank();
+    //fprintf(stderr,"monitor_init_mpi RANK %s\n",OpenSS_mpi_rank);
+    if (!sampling_active) {
+	sampling_active = 1;
+	//fprintf(stderr,"monitor_init_mpi RESUME SAMPLING %d\n",getpid());
+	offline_start_sampling(NULL);
+    }
 }
-#endif
 
-#if defined(_MONITOR_H_)
 void monitor_fini_mpi(void)
 {
     OpenSS_mpi_rank = monitor_mpi_comm_rank();
-    //fprintf(stderr,"OPENSS OpenSS_mpi_rank callback: OpenSS_mpi_rank = %d\n",
-    //OpenSS_mpi_rank);
 }
-#endif
Index: plugins/collectors/fpe/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/fpe/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/fpe/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/fpe/offline.c	26 Mar 2009 19:19:23 -0000
@@ -74,17 +74,21 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
 
-    /* Access the environment-specified arguments */
-    const char* fpe_traced = getenv("OPENSS_FPE_TRACED");
-
     /* Stop sampling */
     fpe_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
+    /* Access the environment-specified arguments */
+    const char* fpe_traced = getenv("OPENSS_FPE_TRACED");
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/hwc/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/hwc/offline.c,v
retrieving revision 1.2
diff -u -a -u -r1.2 offline.c
--- plugins/collectors/hwc/offline.c	26 Mar 2009 17:47:39 -0000	1.2
+++ plugins/collectors/hwc/offline.c	26 Mar 2009 19:19:23 -0000
@@ -99,7 +99,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -107,6 +107,10 @@
     /* Stop sampling */
     hwc_stop_sampling(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/hwctime/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/hwctime/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/hwctime/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/hwctime/offline.c	26 Mar 2009 19:19:23 -0000
@@ -99,7 +99,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -107,6 +107,10 @@
     /* Stop sampling */
     hwctime_stop_sampling(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/io/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/io/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/io/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/io/offline.c	26 Mar 2009 19:19:23 -0000
@@ -76,7 +76,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -86,6 +86,10 @@
     /* Stop sampling */
     io_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Access the environment-specified arguments */
     const char* io_traced = getenv("OPENSS_IO_TRACED");
 
Index: plugins/collectors/iot/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/iot/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/iot/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/iot/offline.c	26 Mar 2009 19:19:23 -0000
@@ -76,7 +76,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -86,6 +86,10 @@
     /* Stop sampling */
     iot_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Access the environment-specified arguments */
     const char* iot_traced = getenv("OPENSS_IO_TRACED");
 
Index: plugins/collectors/mpi/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/mpi/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/mpi/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/mpi/offline.c	26 Mar 2009 19:19:23 -0000
@@ -32,7 +32,8 @@
 #include "blobs.h"
 #include "MPITraceableFunctions.h"
 
-uint64_t mpi_time_started;
+static uint64_t mpi_time_started;
+static int is_tracing = 0;
 extern int OpenSS_mpi_rank;
 
 /**
@@ -46,6 +47,11 @@
  */
 void offline_start_sampling(const char* in_arguments)
 {
+    if (is_tracing) {
+	return;
+    }
+    is_tracing = 1;
+
     mpi_start_tracing_args args;
     char arguments[3 * sizeof(mpi_start_tracing_args)];
 
@@ -74,14 +80,22 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
 
+    if (!is_tracing) {
+	return;
+    }
+
     /* Stop sampling */
     mpi_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/mpiotf/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/mpiotf/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/mpiotf/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/mpiotf/offline.c	26 Mar 2009 19:19:23 -0000
@@ -73,7 +73,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -81,6 +81,10 @@
     /* Stop sampling */
     mpiotf_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/mpit/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/mpit/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/mpit/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/mpit/offline.c	26 Mar 2009 19:19:23 -0000
@@ -32,7 +32,9 @@
 #include "blobs.h"
 #include "MPITTraceableFunctions.h"
 
-uint64_t mpit_time_started;
+static uint64_t mpit_time_started;
+static int is_tracing = 0;
+extern int OpenSS_mpi_rank;
 
 /**
  * Start offline sampling.
@@ -45,6 +47,11 @@
  */
 void offline_start_sampling(const char* in_arguments)
 {
+    if (is_tracing) {
+	return;
+    }
+    is_tracing = 1;
+
     mpit_start_tracing_args args;
     char arguments[3 * sizeof(mpit_start_tracing_args)];
 
@@ -73,14 +80,22 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
 
+    if (!is_tracing) {
+	return;
+    }
+
     /* Stop sampling */
     mpit_stop_tracing(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/mpit/wrappers.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/mpit/wrappers.c,v
retrieving revision 1.15
diff -u -a -u -r1.15 wrappers.c
--- plugins/collectors/mpit/wrappers.c	9 Oct 2008 17:21:22 -0000	1.15
+++ plugins/collectors/mpit/wrappers.c	26 Mar 2009 19:19:23 -0000
@@ -28,6 +28,10 @@
 
 #include <mpi.h>
 
+#if defined (OPENSS_OFFLINE)
+extern int OpenSS_mpi_rank;
+#endif
+
 static int debug_trace = 0;
 
 /*
Index: plugins/collectors/pcsamp/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/pcsamp/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/pcsamp/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/pcsamp/offline.c	26 Mar 2009 19:19:23 -0000
@@ -78,17 +78,21 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
 
-    /* Access the environment-specified arguments */
-    const char* sampling_rate = getenv("OPENSS_PCSAMP_RATE");
-
     /* Stop sampling */
     pcsamp_stop_sampling(NULL);
 
+    if (!finished) {
+	return;
+    }
+
+    /* Access the environment-specified arguments */
+    const char* sampling_rate = getenv("OPENSS_PCSAMP_RATE");
+
     /* Initialize the offline "info" blob's header */
     OpenSS_InitializeDataHeader(0, /* Experiment */
 				1, /* Collector */
Index: plugins/collectors/usertime/offline.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/usertime/offline.c,v
retrieving revision 1.1
diff -u -a -u -r1.1 offline.c
--- plugins/collectors/usertime/offline.c	27 Jan 2009 23:16:51 -0000	1.1
+++ plugins/collectors/usertime/offline.c	26 Mar 2009 19:19:23 -0000
@@ -78,7 +78,7 @@
  *
  * @param in_arguments    Encoded function arguments. Always null.
  */
-void offline_stop_sampling(const char* in_arguments)
+void offline_stop_sampling(const char* in_arguments, const int finished)
 {
     OpenSS_DataHeader header;
     openss_expinfo info;
@@ -86,6 +86,10 @@
     /* Stop sampling */
     usertime_stop_sampling(NULL);
 
+    if (!finished) {
+	return;
+    }
+
     /* Access the environment-specified arguments */
     const char* sampling_rate = getenv("OPENSS_USERTIME_RATE");
 
@@ -127,9 +131,6 @@
 			uint64_t begin, uint64_t end,
 			uint8_t is_dlopen)
 {
-    if (is_dlopen) {
-	usertime_stop_timer();
-    }
     OpenSS_DataHeader header;
     openss_objects objects;
     
@@ -154,7 +155,4 @@
     /* Send the offline "dso" blob */
     OpenSS_SetSendToFile("usertime", "openss-dsos");
     OpenSS_Send(&header, (xdrproc_t)xdr_openss_objects, &objects);
-    if (is_dlopen) {
-	usertime_start_timer();
-    }
 }
Index: plugins/collectors/usertime/runtime.c
===================================================================
RCS file: /cvsroot/openss/OpenSpeedShop/plugins/collectors/usertime/runtime.c,v
retrieving revision 1.25
diff -u -a -u -r1.25 runtime.c
--- plugins/collectors/usertime/runtime.c	27 Jan 2009 23:16:51 -0000	1.25
+++ plugins/collectors/usertime/runtime.c	26 Mar 2009 19:19:23 -0000
@@ -31,6 +31,15 @@
 #include "RuntimeAPI.h"
 #include "blobs.h"
 
+#if defined (OPENSS_OFFLINE)
+#include <setjmp.h>
+
+extern int OpenSS_SetSEGVhandler(void);
+extern sigjmp_buf unwind_jmp;
+extern int OpenSS_unwinding;
+extern int OpenSS_numsegv;
+#endif
+
 #if UNW_TARGET_X86 || UNW_TARGET_X86_64
 # define STACK_SIZE     (128*1024)      /* On x86, SIGSTKSZ is too small */
 #else
@@ -115,7 +124,7 @@
 
 #ifndef NDEBUG
     if (getenv("OPENSS_DEBUG_COLLECTOR") != NULL) {
-        fprintf(stderr,"usertimeTimerHandler sends data:\n");
+        fprintf(stderr,"usertime sends data:\n");
         fprintf(stderr,"time_end(%#lu) addr range [%#lx, %#lx] bt_len(%d) count_len(%d)\n",
             tls->header.time_end,tls->header.addr_begin,
 	    tls->header.addr_end,tls->data.bt.bt_len,
@@ -179,6 +188,7 @@
 #endif
     Assert(tls != NULL);
 
+    //fprintf(stderr,"entered usertimeTimerHandler for %d\n",getpid());
     int framecount = 0;
     int stackindex = 0;
     uint64_t framebuf[MAXFRAMES];
@@ -189,9 +199,18 @@
 
     /* get stack address for current context and store them into framebuf. */
 
+#if defined(OPENSS_OFFLINE)
+    OpenSS_unwinding = 1;
+    if (sigsetjmp(unwind_jmp,1)){
+	printf("[%s:%u] - Caught fault while unwinding\n",__FILE__, __LINE__);
+    } else
+#endif
+
+    {
     OpenSS_GetStackTraceFromContext (context, TRUE, 0,
                         MAXFRAMES /* maxframes*/, &framecount, framebuf) ;
 
+    //fprintf(stderr,"usertimeTimerHandler after OpenSS_GetStackTraceFromContext %d\n",getpid());
     bool_t stack_already_exists = FALSE;
 
     int i, j;
@@ -260,6 +279,12 @@
 	tls->data.bt.bt_len++;
 	tls->data.count.count_len++;
     }
+
+    }
+
+#if defined(OPENSS_OFFLINE)
+    OpenSS_unwinding = 1;
+#endif
 }
 
 
@@ -317,6 +342,11 @@
 
     /* Begin sampling */
     tls->header.time_begin = OpenSS_GetTime();
+
+#if defined (OPENSS_OFFLINE)
+    OpenSS_unwinding = 0;
+    OpenSS_SetSEGVhandler();
+#endif
     OpenSS_Timer(tls->data.interval, usertimeTimerHandler);
 }
 
