////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Silicon Graphics, Inc. All Rights Reserved.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; either version 2.1 of the License, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

/** @namespace OpenSpeedShop

Enclosing namespace for all OpenSpeedShop libraries.

*/

/** @namespace OpenSpeedShop::Framework

Enclosing namespace for the OpenSpeedShop framework library.

*/





/** @mainpage

Open SpeedShop comes with fully featured text-based and graphical user
interfaces, but it is certainly possible that some users will find them
inadequate or simply not to their liking. Hooks are provided in the standard
user interfaces to allow for customization and their use is encouraged. But,
for whatever reason, some adventurous users may wish to take the road less
traveled and create their own tool.

Creating an application performance tool completely from scratch, however, is
an arduous task. In addition to designing and implementing the user interface
itself, one must deal with complex issues such as asynchronous process control,
executable debugging and symbol table formats, application instrumentation,
data collection, and management of large-scale data sets. Several past and
current projects have provided pieces of the necessary infrastructure.

The Open SpeedShop Framework Library, elsewhere simply "the framework", provides
a unified application program interface (API) to the various components required
for building a complete application performance tool. This framework has helped
facilitate the creation of Open SpeedShop's user interfaces. One of the common
goals of most open source projects is to encourage innovation. It is hoped that
this framework will do precisely that.

@section MainPage_S1 How to Use This Documentation

These pages have been generated directly from the framework's source code. As
such they are <em>the</em> definitive guide to the framework. However since the
size of the framework is large, and thus its documentation is also, simply
jumping to the individual class descriptions may be overwhelming. As a result,
the various entity's have been categorized into four "modules" - each of which
has its own overview page that describes that aspect of the framework.

If you are interested in information about a particular class, file, etc., it is
best to use the links at the top of this page to quickly jump to that entity's
documentation.

If you are writing an application performance tool that will use the framework,
the best place to start is with the module @ref ToolAPI "Performance Tool API".

If you are writing a new performance data collector plugin for the framework,
start with the module @ref CollectorAPI "Collector Plugin API".

Finally, if you will be working on the framework itself, start by perusing both
of the above pages, then read the modules @ref Utility "Utility Classes" and
@ref Implementation "Implementation Details". Then jump to documentation for the
particular sections of code you'll be working on.

*/





/** @defgroup ToolAPI Performance Tool API

API for gathering and analyzing application performance data.

This API provides the means by which a tool can gather and analyze application
performance data. The primary goal of this API is to allow the tool developer to
focus on how the data is presented to the end user rather than the details of
how it is gathered and analyzed.

Traditionally application performance tools contain large amounts of platform
dependent code. Processes must be started, stopped, and otherwise controlled.
Some UNIX systems, such as Linux, do this via a
<a href="http://www.die.net/doc/linux/man/man2/ptrace.2.html">ptrace</a>
interface. Others, such as Solaris and IRIX, do this via a
<a href="http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?
coll=0650&db=man&fname=/usr/share/catman/p_man/cat4/proc.z&srch=/proc">/proc</a>
interface. Data must be gathered from these processes. Frequently that involves
accessing high-resolution timers and call stack unwinding - both platform
dependent activities. Once gathered, the data must be mapped back to the
original source. Doing so involves processing executable symbol table and
debugging formats (
<a href="http://sources.redhat.com/gdb/current/onlinedocs/stabs_toc.html">
STABS</a>
,
<a href="http://www.eagercon.com/dwarf/dwarf3std.htm">DWARF</a>
, etc.) that vary from platform to platform. This API is designed to factor out
most of these platform dependent elements so that that tool developer can focus
on presenting the data in an insightful manner.

Many aspects of this API are similar (or even identical) to concepts found in
<a href="http://oss.software.ibm.com/developerworks/opensource/dpcl/">DPCL</a>
and
<a href="http://www.dyninst.org/">Dyninst</a>
. That should not be suprising considering they are fundamental components used
by Open SpeedShop. Much as DPCL extends Dyninst with additional concepts for
working in a cluster environment, this framework extends DPCL with additional
concepts to ease the creation of application performance tools.

@section ToolAPI_S1 Getting Started

To begin using this API, one starts by including ToolAPI.hxx and creating
one or more instances of @link
OpenSpeedShop::Framework::Application Application
@endlink. This class provides a container for storing a related list of threads
that are being monitored by the tool. Initially that container is empty. By
calling member functions such as @link
OpenSpeedShop::Framework::Application::createProcess createProcess()
@endlink the tool can create a new process to be monitored. If, instead, the
tool needs to attach to existing jobs, processes, or threads, member functions
such as @link
OpenSpeedShop::Framework::Application::attachToArraySession attachToArraySession()
@endlink, @link
OpenSpeedShop::Framework::Application::attachToProcess attachToProcess()
@endlink, or @link
OpenSpeedShop::Framework::Application::attachToPosixThread attachToPosixThread()
@endlink, can be used.

Not only does this class hide the ugly details involved in attaching to an
existing process, it also provides some niceties. One of them is that it will
monitor all threads in the application and watching for them to create
additional threads via fork(), pthread_create(), etc. When they do, the
resulting thread is also added to the application.

Once attached to a particular application (one or more threads), tools generally
need to perform three types of operations: @ref ToolAPI_S2 "thread control",
@ref ToolAPI_S3 "data collection", and @ref ToolAPI_S4 "data analysis". Each is outlined
below.

@section ToolAPI_S2 Thread Control

Threads (and processes that contain a single thread) are controlled primarily
through the @link
OpenSpeedShop::Framework::Thread Thread
@endlink and @link
OpenSpeedShop::Framework::ThreadGroup ThreadGroup
@endlink classes. Note that an @link
OpenSpeedShop::Framework::Application Application
@endlink is a @link
OpenSpeedShop::Framework::ThreadGroup ThreadGroup
@endlink by inheritance so anything that applies to the later also applies to
the former.

Each thread is defined as having a particular @link
OpenSpeedShop::Framework::Thread::Status Status
@endlink that describes the execution state of the thread (running, suspended,
terminated, etc.) Member functions @link
OpenSpeedShop::Framework::Thread::getStatus getStatus()
@endlink and @link
OpenSpeedShop::Framework::Thread::isStatus isStatus()
@endlink are provided for querying the state of a given thread. Importantly, the
tool can also change the status of a thread. For example, a tool can suspend a
thread by performing @link
OpenSpeedShop::Framework::Thread::changeStatus
changeStatus(Thread::Suspended)
@endlink.

Note that instances of @link
OpenSpeedShop::Framework::Thread Thread
@endlink are meant to act only as proxy objects that allow the tool to modify
the behavior of the actual underlying thread. Their existence and/or destruction
does not mirror that of the underlying thread and consequently more than one
@link
OpenSpeedShop::Framework::Thread Thread
@endlink may exist for a single underlying thread.

A @link
OpenSpeedShop::Framework::ThreadGroup ThreadGroup
@endlink is simply an arbitrary group of threads, containing zero or more @link
OpenSpeedShop::Framework::Thread Thread
@endlink instances. Each thread may be part of more than one thread group. This
class provides the means to apply operations to a group of threads as a whole
rather than to each thread individually. For example, if the tool needed to
determine the list of threads currently in the suspended state, it could use
@link
OpenSpeedShop::Framework::ThreadGroup::getSubsetWithStatus
Application::getSubsetWithStatus(Thread::Suspended)
@endlink.

@section ToolAPI_S3 Data Collection

The framework implements application performance data collection via the concept
of "collectors". Collectors are individually implemented plugin modules that
each gather one particular type of performance data. The reasons behind
introducing the collector concept are three-fold:

-# <b>Abstraction</b>. The author of the next, newfangled, tool may not be
interested in the details of how data is <em>collected</em>, just how it is
<em>presented</em> to the end user.
-# <b>Reusability</b>. Different tools have different ways of presenting
performance data. A GUI based tool might show a particular type of data in a
pie chart while a CLI based tool might show the same data in sorted columns.
It is beneficial if these tools can share the exact same data collection
components.
-# <b>Extensibility</b>. The type of performance data to be collected can change
over time. New software or hardware platforms are introduced that require new
types of data be collected. By moving the collection mechanisms into plugins,
new types of data can be acoomodated by creating additional plugins.

Upon tool startup the framework library is loaded and searches for collector
plugins in several predefined locations. The tool can access the list of
available collectors at run-time by calling @link
OpenSpeedShop::Framework::Collector::getAllCollectors getAllCollectors()
@endlink which returns an STL set of @link
OpenSpeedShop::Framework::Collector Collector
@endlink objects, one per collector plugin found by the framework. Each
collector object can then be queried for further information.

Collector plugins can specify zero or more parameters that control how that
collector gathers performance data. An example of this would be allowing a tool
to specify the sampling rate (a parameter) for a PC sampling collector. Tools
can determine the parameters for a collector via @link
OpenSpeedShop::Framework::Collector::getParameters getParameters()
@endlink which returns an STL set of @link
OpenSpeedShop::Framework::Parameter Parameter
@endlink objects. Each parameter can be queried to determine its name,
description, and type. Parameters can have <em>any</em> type. The sampling
rate parameter would likely be an integer (<dfn>int</dfn>). However this same
collector might also provide a parameter that allows the tool to specify a
list of functions (<dfn>std::list<Function></dfn>) to which sampling should be
restricted.

@par Aside:
The @link
OpenSpeedShop::Framework::Collector Collector
@endlink and @link
OpenSpeedShop::Framework::Parameter Parameter
@endlink classes, along with @link
OpenSpeedShop::Framework::Metric Metric
@endlink class discussed later are defined as being @link
OpenSpeedShop::Framework::Named named
@endlink objects. All this really means is that these objects have member
functions for returning their unique identifier, a short name, and a more
verbose description of themselves.
@par
Why use a relatively complex system for querying object names and types? Tools
have no direct knowledge of the available collectors at compile-time because the
collector plugins don't have an associated header file that could relay this
information. That implies the tools need a mechanism for discovering the
information at run-time instead. Unfortunately, ISO C++ doesn't have extensive
reflection capabilities built into the language like
<a href="http://msdn.microsoft.com/library/default.asp?
url=/library/en-us/cpguide/html/cpcondiscoveringtypeinformationatruntime.asp">
.NET</a>
or
<a href="http://java.sun.com/j2se/1.4.2/docs/api/
java/lang/reflect/package-summary.html">Java</a>
that would provide this directly.
@par
Then why not just make every parameter a string to simplify things? This would
simplify the tool API. But this would also complicated the collector plugins
quite a bit. Consider the "list of functions" parameter above. If the tool can
only pass a string to the collector, the collector plugin must now contain code
for parsing that string into a list of functions. Not only does the plugin have
to parse the list, it must validate the individual entries as well. When the
plugin can specify a parameter is type <dfn>std::list<Function></dfn> it is
assured that each entry in the list is actually a function. When all parameters
are <dfn>std::string</dfn> it must extensively check the validity of the input.

Every parameter has a default value and each parameter is set to its default
whenever a new @link
OpenSpeedShop::Framework::Collector Collector
@endlink is instantiated. The tool can query the value of each parameter and,
of course, set a parameter to a new value using @link
OpenSpeedShop::Framework::Collector::setParameter setParameter()
@endlink.

Collectors cannot actually <em>do</em> anything until they are attached to a
particular thread. This is accomplished by passing the collector
to either @link
OpenSpeedShop::Framework::Thread::attachCollector Thread::attachCollector()
@endlink, or @link
OpenSpeedShop::Framework::ThreadGroup::attachCollector
ThreadGroup::attachCollector()
@endlink. In actuality the framework makes a copy of the passed object and
attaches that copy to the thread. One for each thread when attaching to a thread
group.

Each collector can be attached to either zero or one thread, but never more than
one thread. Once a collector is attached to a thread it cannot be unattached.
And once attached, a collector's parameters can no longer be modified. These
limitations may seem excessive. They are necessary to remove ambiguity that
would be present if collectors could be moved from thread to thread, or their
parameters changed, arbitrarily. And, in reality, they really aren't all that
limiting because collectors can be copied very easily and any arbitrary number
of collectors can be attached to a single thread.

Once attached to a thread a collector may begin gathering performance data. This
is accomplished by calling @link
OpenSpeedShop::Framework::Collector::startCollecting startCollecting()
@endlink and the converse @link
OpenSpeedShop::Framework::Collector::stopCollecting stopCollecting()
@endlink which can be used to stop data collection. Note that data collection
for a particular collector can be started and stopped any number of times. All
collected data is tagged with time stamps and multiple start/stops simply
result in gaps in the collected data.

@section ToolAPI_S4 Data Analysis

...



@section ToolAPI_S5 Complete Example

The following C++ source code provides a complete example of how this API can
be used to build a working application performance tool:

<pre>

... Pull example source code from "../examples/libftf/tool/main.cxx" ...

</pre>

Obviously real tools will be more complex than this. But the basics of using
the API are illustrated by the above example.

*/





/** @defgroup CollectorAPI Collector Plugin API

...

*/





/** @defgroup Implementation Implementation Details

...

*/





/** @defgroup Utility Utility Classes

...

*/

/** @defgroup GUI GUI Introduction

Enter a Detailed Description here.

<a href="http://www.trolltech.com">Qt</a>
<p>
 *\section intro_the_goal The Goal
 *The goal of the GUI is to provide an intuitive, easy to use, portal to an
 *otherwise complex and overwhelming application.   In the case of Open
 *Speed Shop, we are attempting
 *to put an intuitive interface between the user and their applications
 *performance experiment.   It's a layer that will help the user ask the
 *correct questions and get the correct meaningful answer back regarding,
 *"Where is my application spending all its time and  how can I make it go
 *faster."
 *
 *One objective to this goal is to provide a GUI framework that will provide
 *common consistent base functionality.   One that will prevent a complex
 *set of tools from getting window-itis, yet providing the user with all
 *the necessary control and clues/hints to achieve their end goal.    The
 *GUI base will also provide the necessary flexibility to add new functionality
 *as other developers begin to develop add-ons (plugins) to improve the core
 *set of tools provided.
 *
 *\section intro_to_gui_section The GUI Infrastructure
 *
 *The GUI is broken into 3 basic parts.   The Main Window, PanelContainers,
 *and Panels. 
 *
 *\subsection intro_to_mainwindow The Main Window
 *
 *There is only one Main Window and it is the owner of the 
 *master PanelContainer.   There is only one master PanelContainer and when 
 *it is closed, the GUI exits.
 *
 *The Main Window will handle high level commands like managing the main
 *menu toolbar.  This menu bar is dynamically
 *created from the list of dynamic GUI plugins.   
 *  
 *\subsection intro_to_panel_containers PanelContainers
 *
 *The PanelContainers will provide all the underlying
 *support for screen layout, local menu management, dive management,
 *drag-n-drop, and communication broker.
 *
 *A PanelContainer is an area (container) on the screen where Panels can
 *be placed and managed. 
 *
 *Each PanelContainer will have a simple communication broker to allow
 *Panels to communicate between local and remote Panels. 
 *
 *A PanelContainer is responsible for interacting with the user, via the
 *PanelContainer menu, to add, delete, resize, or move Panels.
 *
 *A PanelContainer can be split either horizontally or vertically into 2
 *PanelContainers. A PanelContainer can contain, one, many, or no Panels.
 *A PanelContainer has no specific knowledge of what a Panel is doing.
 *(i.e. I doesn't know anything about experiments. It just manages the
 *Panels space and any communication with other Panels.) 
 *
 *
 *\subsection intro_to_panels Panels
 *
 *A Panel is where all the nuts-n-bolts knowledge and logic exists for
 *an individual task.    
 *
 *They will handle Panel specific user interaction and interaction with the
 *Framework.
 *
 *A Panel is placed in a PanelContainer. Each Panel is managed by its
 *PanelContainer. A Panel is the base handle for all views. That is each
 *user defined Panel (i.e. performance experiment type) will have a Panel
 *type derived from a base class Panel. Examples of Panel types and their
 *functions would be:
 *
 *\par  o Wizard Panel:
 *The Wizard Panel would be responsible for interviewing the user to aid them
 *in selecting the right performance tool for the job.   After the interview
 *process was completed a command would be passed to the Framework for
 *action.  Upon completion the user would be notified and an appropriate
 *(default) report (Experiment Panel) would be generated for the user.  
  \par  o Top Panel:
 *The Top Panel would be responsible for displaying the top 'n' metrics
 *from a Collector.   It would provide the implementation for fielding
 *requests to find more information about a selected item and for sending 
 *source position updates to a Source Panel.
  \par  o  Source Panel
 *The Source Panel would be responsible for displaying source files to the
 *screen.  It would provide functionality to display line numbers, search, 
 *highlight line segments, and field dive request for more information
 *about specific lines.
  \par  o  ...
 *
 *Panels will look like a "tabbed" view. A Panel can be moved around to
 *be placed near other Panels for association (communication) to be granted.
 *An example of this could be a User Time Panel could be placed near and
 *existing Source Panel, when the user clicks on an object in the User Time
 *Panel that relates to a source line, the nearest Source Panel would be
 *updated (repositioned) to that source line.
 *
 *\section intro_to_panel_plugins Why Panel Plugins?
 *
 *Panels will be loaded as plugins.  It will be the MainWindow's
 *responsibility to locate and configure the GUI to interact with whatever
 *plugins are currently located on the system.   The MainWindow's menus will
 *need to be dynamically configured based on the available plugins.   A
 *plugin directory (directories) will exist with 
 *dynamic libraries to be loaded.   The dynamic libraries may be
 *visible upon loading, or later (on demand), depending on their type.
 *
 *Using plugin technology allows for ease of exending this tool in the
 *future.   It also will keep this tool very lightweight as only the
 *functionality requested needs to be loaded.
 *
 *\section intro_to_gui_plugins All The To-Do About Dynamic GUI Plugins.
 *
 *A dynamic plugin is a GUI component.   A visible or hidden Panel.
 *Each plugin includes the following information to a common structure 
 *in the panel description.
 *
 *At initialization the default location (yet to be determined) or an
 *environment variable FUTURE_TOOL_PLUGIN_DIR is check for the available
 *plugins. Each plugin is openned and a menu structure is created from
 *the plugin header information.
 *
 *Here's what the plugin header information contains:
 *
 *local_plugin_info.h
 *
 *\li plugin_entry->grouping = "PLUGIN_GROUPING";
 *\par Grouping:
 *A general grouping name such as, Performance, Debugging, Static Analysis, ...
 *Currently only "Performance" is being used.
 *\li plugin_entry->show_immediate = SHOW_IMMEDIATE;
 *\par Show Immediate:
 *After loading the plugin file, load the panel to a panel container.
 *\li plugin_entry->plugin_description = "PLUGIN_DESCRIPTION";
 *\par Plugin Description:
 *A short description of the plugin panel (We'll show this with 'about' help.)
 *\li plugin_entry->plugin_name = "libTemplatePanel.so";
 *\par Plugin Name:
 *This is the dso name (Yes, it's redundant.)
 *\li plugin_entry->plugin_location = "$FUTURE_TOOL_PLUGIN_DIR";
 *\par Plugin Location:
 *This is a dynamic absolute path to the dso.
 *\li plugin_entry->plugin_entry_point = "panel_init";
 *\par Plugin Entry Point:
 *The generic entry point that is called to do the menu add. This is
 *separate from _init() to allow the user to still do 'other' initialization
 *if they need to before calling panel_init().
 *\li plugin_entry->menu_heading = "MENU_HEADING";
 *\par Menu Heading:
 *This is the actual heading that will be put to the toplevel menu headings
 *(The panel_init() function will loop through existing headers to see if
 *it needs to add this header or use an existing one.)
 *\li plugin_entry->menu_label = "MENU_LABEL";
 *\par Menu Label:
 *This is the menu entry under the "Menu Heading", added to the end
 *of the list. 
 *\li plugin_entry->menu_accel = "MENU_ACCEL";
 *\par Menu Accel:
 *This will set the menu accelerator for this menu item.
 *Note: It is the panel designers responsiblity to check for conflicts.
 *\li plugin_entry->panel_type = "MENU_LABEL";
 *\par Panel Type:
 *This is a unique string describing the panel type.
 *
 *
 *\section intro_to_starting_gui Into To How The GUI Launches Itself.
 *
 *The GUI is bundled into a dynamic library that is loaded on demand.  It's the *Command Line Interface (CLI) that launches the GUI.   By default the CLI 
 *will launch the GUI upon invocation of the OpenSpeedShop tool.   However,
 *the CLI can be started without starting the GUI ($ oss -cli) and then the 
 *GUI can loaded and initialize when needed.
 *
 *Upon invoking OpenSpeedShop ($ oss) the command line is parsed, and if the
 *GUI is requested the GUI library is loaded and launched.   We then drop into
 *an event loop that parsed both command lines and GUI events.
 *
 *When the GUI is loaded, the GUI looks for GUI plugins in the default
 *directory and in the FUTURE_TOOL_PLUGIN_DIR environment variable path.
 *Each file in the directory is opened and an internal entry point is 
 *queried.   If found the plugin manager calls the entry point, initializes
 *any exported menus, brings up the GUI, then drops into the main event
 *loop waiting for user interaction.
 *
 *\section intro_to_creating_a_panel How do I create the initial panel structure?
 *There's a script 'mknewpanel' in the TemplatePanel directory.
 *(.../Panels/TemplatePanel). Type in 'mknewpanel' to get a usage command.
 *
 *An example to create a new panel template for a panel called "TreePanel"
 *would be to type:
 *
 *$ cd Panels/TemplatePanel
 *
 *$ mknewpanel ../TreePanel TreePanel Performance "Tree Panel" 0 Performance
 *
 *This will create a new Panels directory (TreePanel), name the new panel
 *"TreePanel", and a menu item "Tree Panel" will be placed under the menu
 *entry "Performance". It won't be shown initially (i.e. '0') and it will
 *be associated with the "Performance" group.
 *
 *\section intro_to_default_panels What Panels To Provide by Default?
 *
 *\par o user time experiment
 *\par o input/output experiment
 *\par o hardware counter experiment
 *\par o PC sampling experiment
 *\par o MPI tracing experiment
 */
<p>

<p>
*/
