################################################################################
# Copyright (c) 2008-2009 Krell Institute  All Rights Reserved.
#
# This library is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
################################################################################

import types
import code
import os
import os.path
import re
import string
import sys

import PY_Input

def create_unique_dbname(db_name):
    cnt = 1
    base_name, ext = os.path.splitext(db_name)
    # Python 2.3 does not have lexists which would be prefered here.
    while os.path.isfile(db_name):
	db_name = "%s-%d%s" % (base_name, cnt, ext)
	cnt += 1
    return db_name



def RunOfflineExp(program="*", collector="*", installed="/usr"):
    """Run offline experiment for Open|SpeedShop.
    """

    #Check For OPENSS_PREFIX and use it.  That is, only if
    #installed's default value has not changed.  Allows
    #users to explicitly define a different OSS installation path (even
    #if OPENSS_PREFIX is defined).
    if os.environ.has_key("OPENSS_DEBUG_CLI_PYTHON_GC"):
        gc.set_debug(gc.DEBUG_LEAK)
        gc.get_objects()
    gc.disable()
    if (os.environ.has_key("OPENSS_PREFIX") and installed == "/usr"):
        installed = os.environ["OPENSS_PREFIX"]
        print "[openss]: Using OPENSS_PREFIX installed in " + installed
    
    # set up plugins path
    if os.environ.has_key("OPENSS_TARGET_PLUGIN_PATH"):
        plugins = os.environ["OPENSS_TARGET_PLUGIN_PATH"]
    elif os.environ.has_key("OPENSS_PLUGIN_PATH"):
	plugins = os.environ["OPENSS_PLUGIN_PATH"]
    else:
	plugin_dir =  OpenssInstallDir + "/lib64/openspeedshop"
	if not os.path.isdir(plugin_dir):
	    plugin_dir =  OpenssInstallDir + "/lib/openspeedshop"
        if not os.path.isdir(plugin_dir):
	    raise RuntimeError("Failed to locate the openspeedshop plugins directory.")
	plugins = plugin_dir

    rawdir = "/tmp"

    # always write into /tmp/$USER/offline-oss or
    if 'OPENSS_RAWDATA_DIR' in os.environ:
	rawdir = os.environ["OPENSS_RAWDATA_DIR"]
	print "[openss]: Setting up offline raw data directory in " + rawdir + "/offline-oss"
	tempdir = rawdir + "/offline-oss"
	os.system("/bin/rm -rf " + tempdir)
	os.mkdir(tempdir)
	os.environ['OPENSS_RAWDATA_DIR'] = tempdir
    else:
	if 'USER' in os.environ:
	    user = os.environ["USER"]
	else:
	    user = os.path.expanduser(os.getlogin())

	tempdir = rawdir + "/" + user + "/offline-oss"
        if not collector == "mpiotf":
	  print "[openss]: Setting up offline raw data directory in " + tempdir
	if not os.path.isdir(tempdir):
	    os.makedirs(tempdir)
	else:
	    # Empty rawdata from any previous offline experiment
	    # and then recreate the raw data directory.
	    shutil.rmtree(tempdir);
	    os.makedirs(tempdir)
	os.environ['OPENSS_RAWDATA_DIR'] = tempdir

    # Locate the libmonitor directory
    # If OPENSS_PREFIX is set, do not assume libmonitor is there.
    # The following test ensures that installed (either /usr or the
    # path from OPENSS_PREFIX) does indeed have a proper libdir.
    libdir = installed + "/lib64"
    if not os.path.isdir(libdir):
        libdir = installed + "/lib"
    if not os.path.isdir(libdir):
        raise RuntimeError("[openss error]: Failed to locate the libmonitor library directory.")

    # Locate the monitor-run command and libmonitor runtime dso.
    # If libmonitor.so is not found in the "installed" path, then
    # fallback to /usr and try again (again, do not assume libmonitor
    # was installed into OPENSS_PREFIX.
    libmonitor = "@@libmonitordir@@/lib64/libmonitor.so"
    if not os.path.isfile(libmonitor):
     libmonitor = "@@libmonitordir@@/lib/libmonitor.so"
     if not os.path.isfile(libmonitor):
      libmonitor = libdir + "/libmonitor.so"
      if not os.path.isfile(libmonitor):
	systemdir = "/usr"
	libdir = systemdir + "/lib64"
	if not os.path.isdir(libdir):
	    libdir = systemdir + "/lib"
	if not os.path.isdir(libdir):
            raise RuntimeError("[openss error]: Failed to locate the libmonitor library directory.")
	libmonitor = libdir + "/libmonitor.so"
	if not os.path.isfile(libmonitor):
            raise RuntimeError("[openss error]: Failed to locate the libmonitor.so library. " + libmonitor)

    # Set the default mpi implementation defined by the O|SS configuration.
    default_mpi_impl = "@@ossdefaultmpi@@"

    program_list = program.split()

    # We need to see if any of the programs participating in the
    # experiment are an mpi program. If so we need to include the
    # mpi plugin and trace only MPI_Init to gather the mpi rank info.
    # If we find there is no mpi program then we do not need the mpi
    # plugin aded to preload_files.
    mpi_executable = ""
    mpi_exe_implmentation = ""
    ismpi = bool(0)
    mpi_driver = ""
    path_list = os.path.expandvars("$PATH").split(":")

    for s in program_list:
	file_arg = s
	if s.startswith("~"):
	    file_arg = s.replace("~", os.path.expanduser("~"))
	    program = program.replace("~", os.path.expanduser("~"))
	    
	for p in path_list:
	   if not os.path.isfile(s) and not ismpi \
	      and not s.startswith("-"):
		file_arg = p + "/" + s
		if os.path.isfile(file_arg):
		    break
		else:
		    file_arg = s

# being code to replace aliases
#
#       Recognize an alias for the executable and replace the alias with the actual value
#       We must recognize the shell the user is running and execute the alias command using
#       that shell, for example:  /bin/csh -c "alias executable"
#       to see if there is an alias for executable.   Then use the replace command in the
#       file_arg and program strings to put in the real command.
        if os.environ.has_key("OPENSS_ALIAS_DETECTION"):
            result = ""
            mySHELL = 'echo $SHELL'
            myshell_result = commands.getoutput(mySHELL)
            if myshell_result.find("tcsh") != -1 or myshell_result.find("csh") != -1:
               myAliasCommand = "alias " + file_arg
               myAliasString = myshell_result + ' -c "' + myAliasCommand + '"'
               result = commands.getoutput(myAliasString)
               if result != "":
                  program = program.replace(file_arg, result)
                  file_arg = s.replace(file_arg, result)

# end code to replace aliases
	
	if os.path.isfile(file_arg):
	    # test if the file is elf binary and has the symbol MPI_Init.
	    # We use os.WEXITSTATUS to properly decode the status.
	    isexecutable = os.system('file -L ' + file_arg + ' | grep -q ELF')

	    if not os.WEXITSTATUS(isexecutable):
		# is this the actual mpi program.
		if not ismpi:
		  ismpidriver = os.system('nm ' + file_arg + ' | grep -q -i MPIR')
		  if not os.WEXITSTATUS(ismpidriver):
		    ismpi = bool(1)
		    mpi_driver = os.path.realpath(file_arg)
		    orig_mpi_driver = s
                    program = program.replace(file_arg, mpi_driver)
		    preload_files = ""
		    if ismpi:
			islampi = os.system('nm ' + file_arg + ' | grep -q lampi_environ_init')
			ismpt = os.system('nm ' + file_arg + ' | grep -q  MPI_debug_breakpoint')
			islam = os.system('nm ' + file_arg + ' | grep -q  lam_tv_init')
			isopenmpi = os.system('nm ' + file_arg + ' | grep -q orterun')
		        if not os.WEXITSTATUS(isopenmpi):
		          mpi_exe_implmentation = "openmpi"
		        elif not os.WEXITSTATUS(islam):
		          mpi_exe_implmentation = "lam"
		        elif not os.WEXITSTATUS(islampi):
		          mpi_exe_implmentation = "lampi"
		        elif not os.WEXITSTATUS(ismpt):
		          mpi_exe_implmentation = "mpt"

		        continue

		# is this the mpidriver and what implementation is it.
		if ismpi:
		  has_mpi_init = os.system('nm ' + file_arg + ' | grep -q -i MPI_Init')
                  #
                  # Do not require that the mpi program run by mpirun have the
                  # symbol MPI_Init.  i.e. mpirun -np 2 /bin/date should be allowed.
                  # We do not find MPI in the file_arg and there is a specific MPI IMPLEMENTATION known
                  # So, we assign the file_arg as the mpi executable.
                  #
                  if os.WEXITSTATUS(has_mpi_init) and not len(mpi_exe_implmentation) == 0:
                    mpi_executable = file_arg
                    break
                  #
                  # We do not find MPI in the file_arg 
                  # So, if the OPENSS_MPI_IMPLEMENTATION variable is set then we can assign the file_arg as the mpi executable.
                  # Why?  There are use cases where the user has an executable that does not contain MPI symbols but is an
                  # MPI executable because they use dlopen to load the MPI code into the executable later.
                  #
                  if os.WEXITSTATUS(has_mpi_init) and not os.environ["OPENSS_MPI_IMPLEMENTATION"] == "":
		    mpi_executable = file_arg
		    break
		  if not os.WEXITSTATUS(has_mpi_init):
		    mpi_executable = file_arg
		    break
		  if mpi_exe_implmentation == "mpich2":
		    mpi_executable = file_arg
		    break
		  if mpi_exe_implmentation == "mpt":
		    mpi_executable = file_arg
		    break
		  if mpi_exe_implmentation == "openmpi":
		    mpi_executable = file_arg
		    break
		  if mpi_exe_implmentation == "mvapich":
		    mpi_executable = file_arg
		    break
		  if mpi_exe_implmentation == "mvapich2":
		    mpi_executable = file_arg
		    break
	    else:
		isscript = os.system('file -L ' + file_arg + ' | grep -q script')
		if not os.WEXITSTATUS(isscript):
		  # Lets hope the mpich2 driver always has Argonne in its copyright.
		  ismpich = os.system('grep -q -i \"MPIRUN for MPICH\" ' + file_arg)
		  ismpich2 = os.system('grep -q -i Argonne ' + file_arg)
                  ismvapich = os.system('grep -q -i \"Wrapper for job submission on Hert related machines\" ' + file_arg)
                  ismvapich2 = os.system('grep -q -i \"MVAPICH2 software package developed\" ' + file_arg)

		  # if both ismpich2 and ismvapich2 are set, choose mpich2
		  if not os.WEXITSTATUS(ismpich2) and not os.WEXITSTATUS(ismvapich2):
			ismpich2 = bool(0)

		  if os.WEXITSTATUS(ismpich2):
			ismpich2 = os.system('grep -q -i Intel ' + file_arg)

		  isMPT = os.system('grep -q -i sgimpirun ' + file_arg)
		  isopenmpi = os.system('grep -q -i orterun ' + file_arg)
                  if not os.WEXITSTATUS(ismpich):
                    ismpi = bool(1)
                    mpi_driver = os.path.realpath(file_arg)
                    orig_mpi_driver = s
                    program = program.replace(s, file_arg)
                    preload_files = ""
                    mpi_exe_implmentation = "mpich"
		  if not os.WEXITSTATUS(ismpich2):
		    ismpi = bool(1)
		    mpi_driver = os.path.realpath(file_arg)
		    orig_mpi_driver = s
		    program = program.replace(s, file_arg)
		    preload_files = ""
		    mpi_exe_implmentation = "mpich2"
		  if not os.WEXITSTATUS(isMPT):
		    ismpi = bool(1)
		    mpi_driver = os.path.realpath(file_arg)
		    orig_mpi_driver = s
		    program = program.replace(s, file_arg)
		    preload_files = ""
		    mpi_exe_implmentation = "mpt"
		  if not os.WEXITSTATUS(isopenmpi):
		    ismpi = bool(1)
		    mpi_driver = os.path.realpath(file_arg)
		    orig_mpi_driver = s
		    program = program.replace(s, file_arg)
		    preload_files = ""
		    mpi_exe_implmentation = "openmpi"
		  if not os.WEXITSTATUS(ismvapich):
                    ismpi = bool(1)
                    mpi_driver = os.path.realpath(file_arg)
                    orig_mpi_driver = s
                    program = program.replace(s, file_arg)
                    preload_files = ""
                    mpi_exe_implmentation = "mvapich"
		  if not os.WEXITSTATUS(ismvapich2):
                    ismpi = bool(1)
                    mpi_driver = os.path.realpath(file_arg)
                    orig_mpi_driver = s
                    program = program.replace(s, file_arg)
                    preload_files = ""
                    mpi_exe_implmentation = "mvapich2"



    # Set the mpiplugin to use for mpi jobs.  The OPENSS_MPI_IMPLEMENTATION
    # is primarily used to choose a different mpi (e.g. mpich vs. openmpi)
    # for systems that have more than on mpi implementation configured for
    # use with O|SS.
    use_mpi_impl = ""

    if ismpi:

      if 'OPENSS_MPI_IMPLEMENTATION' in os.environ:
	use_mpi_impl = os.environ["OPENSS_MPI_IMPLEMENTATION"]
      else:
	if mpi_exe_implmentation == "":
	    use_mpi_impl = default_mpi_impl.lower()
	else:
	    use_mpi_impl = mpi_exe_implmentation

      if mpi_executable == "":
	if use_mpi_impl == "":
            raise RuntimeError("[openss error]: Failed to locate the mpi program.")
        else:
            if not os.WEXITSTATUS(ismpidriver):
               mpi_executable = file_arg
            else:
               raise RuntimeError("[openss error]: Failed to locate the mpi program.")

      mpiplugin = plugins + "/mpi-" + use_mpi_impl + "-rt-offline.so"

      os.environ['OPENSS_MPI_IMPLEMENTATION'] = use_mpi_impl

      if not os.path.isfile(mpiplugin):
	# TODO: This should only error out for cases where something
	# like pcsamp is the collector and there should be mpi too.
	#raise RuntimeError("Failed to locate the mpi runtime plugin. " + libmonitor)
	print "[openss warning]: Failed to locate the mpi runtime plugin. " + mpiplugin
	print "[openss warning]: No MPI rank identifiers will be recorded in the openss database."
    else:
	mpiplugin = ""

    # Allow the user to just use the know mpi and mpit collector names.
    # We will prepend the prper mpi implementation.
    orig_collectorname = collector;
    if collector.startswith("mpi"):
	preload_files = ""
	if collector == "mpi":
	    collector = collector + "-" + use_mpi_impl
	elif collector == "mpit":
	    collector = collector + "-" + use_mpi_impl
        elif collector == "mpiotf":
            collector = collector + "-" + use_mpi_impl
    else:
	# In case this may be an mpi program, setup preload_files to
	# also include the mpi plugin.  
	# dpm/jeg 10/15/08 - Removed setting of OPENSS_MPI_TRACED here.
	# The new ossrun sets it instead of doing it here.
	preload_files = mpiplugin

    # Form the command that will run the offline experiment
    # For MPI programs we will call ossrun to handle setting up the
    # collector for just the actual mpi program and not the mpi driver too.

    if mpi_executable != "":
	mpi_exe_orig = mpi_executable
        if not mpi_executable.startswith("/") and not mpi_executable.startswith("."):
	    mpi_executable = os.curdir + "/" + mpi_executable

        if collector == "mpiotf":
           ossrun_command = OpenssInstallDir + "/bin/ossrun -o " + os.environ['OPENSS_RAWDATA_DIR']
        else:
           ossrun_command = OpenssInstallDir + "/bin/ossrun"

 	command = program.replace(mpi_exe_orig, ossrun_command + " -c " + orig_collectorname + " \"" + mpi_executable)
 	command = command + "\" " 

    else:
	preload_files = ""
	command = program
	if not command.startswith("/") and not command.startswith("."):
	    command = os.curdir + "/" + command

    collectorplugin =  plugins + "/" + collector + "-rt-offline.so"

    if not os.path.isfile(collectorplugin):
	raise RuntimeError("[openss error]: Failed to locate the " +  collector + " runtime plugin.")
	# this code below could replace the error here so we could
	# just let the program run without our data collectors.
	#collectorplugin = ""
	#preload_files = ""

    # Prepare our collectors and libmonitor for LD_PRELOAD.
    oss_preload = ""
    if mpi_executable == "":
        oss_preload = \
              collectorplugin + \
	      ":" + preload_files + \
	      ":" + libmonitor


    # Execute the command in a subprocess rather than replacing the
    # current process like os.system does. Need Python 2.4 or later for this.
    print "[openss]: Running offline %(col)s experiment using the command:\n\"%(cmd)s\"\n" \
	   % {'col':collector,'cmd':command}

    python_ver = sys.version[0:3]
    if python_ver > "2.3":
	# For python versions > 2.4 we run mpi programs using the Popen method
	# of the subprocess class.  If the program is not MPI then just use
	# the os.system call.
	if mpi_executable == "":
	    # This is the easiest way for simple scalar programs.
	    # We do not need to worry about interfering with
	    # interactive programs and muck with any stdIO here.
	    # If we can handle an interactive programm (like openss itself)
	    # with the subprocess method then we should eventually do that.
	    command = "env" +  \
             " LD_PRELOAD=" + oss_preload + ":$LD_PRELOAD " + command

	    #print "\n[openss debug]: USING os.system to execute " + command
	    os.system(command)
	else:
	    # This is specificly here for mpi programs.
	    command = "env" +  \
             " LD_PRELOAD=" + oss_preload + ":$LD_PRELOAD " + command

	    #print "\n[openss debug]: USING os.system to execute " + command
	    os.system(command)

	# Comment out the subprocess code for now.
	    #import subprocess
	    #subp = subprocess.Popen(command, shell=True,
	#			    stdout=subprocess.PIPE,
	#			    stdin=subprocess.PIPE,)
				    #env={"LD_PRELOAD":oss_preload})
	#    while True:
	#        o = subp.stdout.readline()
	#        if o == '' and subp.poll() != None: break
	#        sys.stdout.write(o)

    else:
	# For python 2.3 just run the experiment using os.system.
	# This includes mpi programs.
	command = "env" +  \
             " LD_PRELOAD=" + oss_preload + ":$LD_PRELOAD " + command
	os.system(command)

    if not collector.startswith("mpiotf"):
	oss_cur_dir = os.getcwd()
	oss_db_dir = os.getcwd()
	if os.environ.has_key("OPENSS_DB_DIR"):
	    oss_db_dir = os.environ['OPENSS_DB_DIR']
	    os.chdir(oss_db_dir)

        print "\n[openss]: Converting raw data from %(rawdata)s into temp file %(ossfile)s\n" \
          % {'rawdata':os.environ['OPENSS_RAWDATA_DIR'],'ossfile':"X.0.openss"}

	# currently ossutil writes openss databases to ever increasing
	# database files from the lowest it finds.
	# Lets just always remove X.0.openss so that is our default for now.
	# Always defaulting to X.0.openss allows us to use restore below with
	# no need to worry about finding which file was just written.
	clean_command = "/bin/rm -f " + oss_db_dir + "/X.0.openss"
	os.system(clean_command)

	# Convert the rawdata files into opens database format.
	convert_command = OpenssInstallDir + "/bin/ossutil " + os.environ['OPENSS_RAWDATA_DIR']
	os.system(convert_command)

	# rename the default X.0.openss database with program name
	# and collector name as a base.  The create_unique_dbname call
	# will ensure we do not overwrite and existing openss database
	# by bumping a count and prepending it before the .openss extension.
	if mpi_executable == "":
	    ossdbfile = os.path.basename(program)
	else:
	    ossdbfile = os.path.basename(mpi_executable)


	# Remove spaces and any arguments to the program.
	prgwargs = ossdbfile.split(" ")
	ossdbfile = prgwargs[0] +  "-" + collector

	tfile = ossdbfile + ".openss"
	tfile = create_unique_dbname(tfile)
	# Python 2.3 does not have lexists which would be prefered here.
	if  os.path.isfile('X.0.openss'):
	    os.rename('X.0.openss',tfile)
	else:
	    print "\n[openss error]: could not find X.0.openss"
	    return

        print "\n[openss]: Restoring and displaying default view for:\n\t" + oss_db_dir + "/" + tfile

        # restore the newly created database into openss.
        r_line = myparse.process("exprestore -f " + oss_db_dir + "/" + tfile)
        myparse.runsource(r_line, "stderr")

        # restore original rawdata directory
        os.environ['OPENSS_RAWDATA_DIR'] = rawdir
        # restore current working directory
        if os.environ.has_key("OPENSS_DB_DIR"):
            os.chdir(oss_cur_dir)
    else:
	print "\n[openss]: Open Trace Files (OTF) files have been created.  Use an appropriate tool for viewing the OTF files."

